/** @module util/popover */

export {
  open,
  openDropdown,
  positionFixed
}

declare var Meteor: any
import 'jquery'
declare var $: any;
export type JQuery = any;
import { MultiEmitter } from './emitter'
export type Edge = 'top' | 'bottom' | 'left' | 'right'

export interface PositionOptions {
  /**
   * Number between 0 === left and 1 === right, 0.5 === center.
   * 0/left by default
   */
  align?: number

  /**
   * Currently only top and bottom are supported
   * Defaults to bottom
   */
  where?: Edge | Edge[]

  /**
   * Whether the element to should match the width of the relativeTo element
   * Defaults to false
   */
  matchElementWidth?: boolean,

  /**
   * Add a triangle to the thing we're pointing at?
   * Defaults to false
   */
  triangle: boolean,

  /**
   * How much space should we try to allow around the edge of the window (top, right, bottom, left)
   * Defaults to 10, 10, 10, 10
   */
  gutter?: [number, number, number, number],

  /**
   * CSS selector. If specified, will hide the matching element if it has a CSS variant
   * (-top, -right, -bottom, -left) that doesn't match the element's rendered position
   */
  positionVariantSelector?: string,

  allowResize?: boolean,

  /**
   * Specify viewport to use to determine element's position
   */
  parent?: JQuery | object
}

interface Opposites {
  top: string,
  bottom: string,
  left: string,
  right: string,
  [key: string]: string
}

const opposites: Opposites = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
}

export interface PopoverOptions {

  /**
   * Should the popover opened match the width of the target element?
   */
  matchElementWidth: boolean,

  /**
   * Where abouts should the popover be aligned horizontally? 0 == left, 1 == right,
   * 0.5 center and everywhere in between
   */
  xAlign: number,

  /**
   * Any classes to be applied to the opened popover
   */
  css: string,

  /**
   *
   */
  overflow: boolean,

  /**
   * Is this popover a dropdown?
   */
  dropdown: boolean
}

export type PopoverContent = string | { template: string, data?: any } | JQuery

export interface SpecialDropdownItem {
  /**
   * The action that should run upon clicking the dropdown (the dropdown will automatically close after running this)
   */
  action: Function,

  /**
   * The textual representation of this menu item that appears in the dropdown
   */
  name: string,

  /**
   * Sub items of this item (optional)
   */
  items?: DropDownItem[],

  /**
   * Any special css classes as a space-separated string that should be applied to this item specificially
   */
  css?: string
}

export type DropDownItem = string | SpecialDropdownItem

/**
 * Opens a popover with the specified content located on the edge of the source object
 * @param source the target element this popover should be attached to
 * @param content the content to show in the popover
 * @param options
 */
function open(source: HTMLElement, $content: PopoverContent, options: PopoverOptions) {

  const multiEmitter = new MultiEmitter();
  const $source = $(source)
  const $contentWrap = $('<div class="content">').append($($content))
  let closed = false

  options = _.extend({
    matchElementWidth: true,
    xAlign: 0.5,
    css: '',
    overflow: false
  }, options)

  const additionalClasses = source.className.split(' ').map(function (c) {
    return '-popover-source-' + c
  }).join(' ') + ' ' + (options.css || ''.trim())

  const clickCatch = $('<div id="popover-click-catch">').css({
    position: 'absolute',
    width: '100%',
    height: '100%',
    top: '0',
    left: '0'
  }).click(function (e: any) {
    if ($(e.target).attr('id') === 'popover-click-catch') {
      close()
    }
  })

  $contentWrap.addClass(additionalClasses)
  $contentWrap.css({
    position: 'absolute',
    display: 'none',
    width: options.matchElementWidth ? ($source.outerWidth() + 'px') : ''
  })

  // Add to DOM in order to perform size calculations and add blaze template etc.
  let wrap = $('<div>').addClass('popover-wrap').css({
    position: 'fixed',
    width: '100%',
    height: '100%',
    top: '0',
    left: '0'
  })
  wrap.append(clickCatch, $contentWrap)
  wrap = wrap.appendTo($('body'))

  $contentWrap.css({
    visibility: 'hidden',
    display: ''
  })

  const requiredHeight = $contentWrap.outerHeight()
  const viewportPos = viewportPosition($source)
  const elSize = [$source.outerWidth(), $source.outerHeight()]
  const leftPos = viewportPos[0] + (elSize[0] * options.xAlign) - ($contentWrap.outerWidth() * options.xAlign)

  if (options.dropdown) {
    options.overflow = false
    const pad = 25
    let totalHeight: number
    if (options.overflow) {
      totalHeight = requiredHeight
    }
    else {
      totalHeight = Math.min(500, requiredHeight, (window.innerHeight - 100) / 2)
    }
    let top = (viewportPos[1] + elSize[1])

    if (top + totalHeight > window.innerHeight) {
      top -= (elSize[1] + totalHeight)
    }

    $contentWrap.css({
      'left': leftPos + 'px',
      'top': top + 'px',
      'overflow-y': options.overflow ? 'visible' : 'auto',
      'overflow-x': 'visible',
      'height': totalHeight
    })
  } else {
    $contentWrap.css({
      'left': leftPos + 'px',
      'top': Math.min(viewportPos[1] + elSize[1]) + 'px'
    })
  }

  if (options.matchElementWidth) {
    $contentWrap.css({
      'width': elSize[0] + 'px'
    })
  }

  $contentWrap.removeClass('-above').addClass('-below')
  $contentWrap.css({
    visibility: ''
  })
  $source.addClass('-popover-open')

  function close() {
    if (closed) {
      return
    }
    $source.removeClass('-popover-open')
    wrap.remove()
    closed = true
    multiEmitter.broadcast('close')
  }

  $(window).on('resize.dropdown', close)
  return {
    events: multiEmitter,
    popover: $contentWrap,
    close: close
  }
}

/**
 * Opens a dropdown, which internally is still a popover with some special additions
 * @param source which element should the dropdown be attached to?
 * @param dropDownItems the items that should be shown in the dropdown @see DropDownItem
 * @param options
 */
function openDropdown($source: HTMLElement, dropDownItems: DropDownItem[], options: PopoverOptions) {
  let dropDownItemsGetter: () => DropDownItem[] = dropDownItems as any
  if (typeof (dropDownItems) !== 'function') {
    dropDownItemsGetter = function () {
      return dropDownItems
    }
  }

  if (!dropDownItemsGetter().length) {
    return console.warn('Tried to open an empty dropdown')
  }

  const dropDown = $(`<div class="dropdown"></div>`)
  let hasSubMenus = false

  function addScrollClass(element: JQuery) {
    const normal = $(element)[0]
    const canScroll = (normal.offsetHeight < normal.scrollHeight) && element.scrollTop() === 0
    $(element).toggleClass('-can-scroll', canScroll)
  }

  function addScrollHandlers(element: JQuery) {
    $(element).scroll(function () {
      addScrollClass(element)
    })
  }

  function positionSubMenu(subMenu: JQuery, parent: HTMLElement) {
    let css: any = {
      position: 'fixed',
      top: '',
      bottom: '',
      overflow: '',
      maxHeight: ''
    }
    subMenu.css(css)

    const parentMenu = $(parent).parent()
    const parentLeft = $(parentMenu).offset().left - $(window).scrollLeft()

    const parentItem = parent
    const parentItemTop = $(parentItem).offset().top - $(window).scrollTop()
    const parentItemHeight = $(parentItem).outerHeight()
    const parentItemMidY = parentItemTop + parentItemHeight / 2

    let top = parentItemMidY - $(subMenu).outerHeight() / 2
    let bottom = top + $(subMenu).outerHeight()

    function bottomSpace() {
      return window.innerHeight - 25 - bottom
    }

    function topSpace() {
      return top - 25
    }

    if (topSpace() < 0) {
      let topSpaceNow = topSpace()
      // move down
      top -= topSpaceNow
      bottom -= topSpaceNow
    }
    if (bottomSpace() < 0) {
      // going over on the bottom now? clip
      bottom += bottomSpace()
    }

    css = {
      position: 'fixed',
      top: top + 'px',
      bottom: (window.innerHeight - bottom) + 'px',
      overflow: 'auto',
      maxHeight: '95vh'
    }

    const spaceOnRight = window.innerWidth -
      (parentMenu.offset().left + parentMenu.outerWidth())
    const hasSpaceOnRight = spaceOnRight >= subMenu.outerWidth()

    if (hasSpaceOnRight) {
      css['left'] = (parentLeft + $(parentMenu).width()) + 'px'
    } else {
      css['right'] = (window.innerWidth - parentLeft) + 'px'
    }

    subMenu.css(css)
    addScrollClass(subMenu)
  }

  function htmlForItem(item: DropDownItem) {
    if (typeof (item) === 'string') {
      if (item[0] === '_') {
        return $(`<div class=${item.substr(1)}>`)
      }

      return $(`<div class='heading'>${item}</div>`)
    }

    const html = $(`<div class="item">${item.name}</div>`).click(function (e: any) {
      // No click action on sub items
      if (!item.items && typeof (item.action) === 'function') {
        const clicked = $(e.currentTarget)
        clicked.addClass('-clicked')
        const flash = () => clicked.addClass('-flashing')
        const unflash = () => clicked.removeClass('-flashing')
        let ops = [flash, unflash, flash, function () {
          popoverResult.close()
        }, item.action]

        const process = () => {
          if (ops.length > 0) {
            setTimeout(function () {
              ops.shift()()
              process()
            }, 75)
          }
        }

        process()
      }
    }).hover(function (over: any) {
      html.addClass('-dropdown-hovering')
      if ($(this).children('.subMenu').length) {
        positionSubMenu($(this).children('.subMenu'), this)
      }
    }, function (out: any) {
      if ($(this).closest('-dropdown-hovering').length === 0) {
        html.removeClass('-dropdown-hovering')
      }
    }).addClass(item.css || '')

    if (item.items && item.items.length > 0) {
      hasSubMenus = true
      const subMenu = $(`<div class="subMenu">`)
      item.items.forEach(function (subItem) {
        subMenu.append(htmlForItem(subItem))
      })
      subMenu.appendTo(html)
      addScrollHandlers(subMenu)
      html.addClass('-has-subMenu')
    }

    return html
  }

  dropDownItemsGetter().forEach(item => dropDown.append(htmlForItem(item)))
  addScrollHandlers(dropDown)
  const popoverResult = open($source, dropDown, _.extend({}, options, {
    dropdown: true,

    // A limitation in our implementation stops it being possible from having submenus AND
    // overflow: scroll, because overflow-y: auto implies overflow-x: auto too :(
    overflow: hasSubMenus
  }))
  addScrollClass(dropDown)

  function getSelected() {
    return popoverResult.popover.find('.item.-selected')
  }

  return {
    popover: popoverResult,
    close: popoverResult.close,
    up: () => {
      ifLet([getSelected().prev('.item')[0]], prev => {
        getSelected().removeClass('-selected')
        $(prev).addClass('-selected')
      }, () => {
        getSelected().removeClass('-selected')
        popoverResult.popover.find('.item').last().addClass('-selected')
      })
    },
    down: () => {
      ifLet([getSelected().next('.item')[0]], next => {
        getSelected().removeClass('-selected')
        $(next).addClass('-selected')
      }, () => {
        getSelected().removeClass('-selected')
        popoverResult.popover.find('.item').first().addClass('-selected')
      })
    },
    acceptSelected: () => {
      getSelected().removeClass('-selected').trigger('click')
    }
  }
}

/**
 * Internal function used to run a specific callback with a value if it exists
 * @param toCheck the value, or values to check
 * @param ifCallback the callback to run with the value if it exists
 * @param elseCallback the callback to run if the value does not exist
 */
function ifLet<T>(toCheck: T[], ifCallback: (value: T) => void, elseCallback: Function) {
  if (!Array.isArray(toCheck)) {
    toCheck = [toCheck] as any
  }
  if (toCheck.every(arg => arg !== null && arg !== undefined)) {
    return ifCallback.apply(this, toCheck)
  }
  else if (elseCallback) {
    return elseCallback()
  }
}

/**
 * Internal function used to get the viewport position of an element
 * @param element
 */
function viewportPosition(element: JQuery, parent: object | JQuery = document) {
  return [
    $(element).offset().left - $(parent).scrollLeft(),
    $(element).offset().top - $(parent).scrollTop()
  ]
}

/**
 * Adds a triangle to point at the edge of one element (element) to a target (pointingAt)
 * @param element the element doing the pointing
 * @param positionedWhere where is the popup in relation to the target
 * @param pointingAt what should it point at
 * @param container where do we add the triangle
 * @returns the triangle element
 */
function addTriangleToFixedElement(element: JQuery, positionedWhere: Edge, pointingAt: JQuery, container: JQuery = $('body')): JQuery {

  const triangleSize = 15
  const triangleSizeStr = triangleSize + 'px'
  const triangleCss = {
    position: 'fixed',
    top: '100%',
    height: 0,
    width: 0,
    borderTop: `solid ${triangleSizeStr} transparent`,
    borderBottom: `solid ${triangleSizeStr} transparent`,
    borderLeft: `solid ${triangleSizeStr} transparent`,
    borderRight: `solid ${triangleSizeStr} transparent`,
    [`border-${positionedWhere}-color`]: 'white'
  }
  const triangle = $('<div>').addClass('popover-triangle').css(triangleCss).appendTo(container)

  element.css('margin-' + opposites[positionedWhere], triangleSizeStr)
  const pointingAtPos = viewportPosition(pointingAt)
  const pointingAtSize = [pointingAt.outerWidth(), pointingAt.outerHeight()]

  if (positionedWhere === 'right') {
    triangle.css({
      'left': (pointingAtPos[0] + pointingAtSize[0] - triangleSize) + 'px',
      'top': (pointingAtPos[1] + (pointingAtSize[1] / 2) - triangleSize) + 'px'
    })
  }
  else if (positionedWhere === 'left') {
    triangle.css({
      'left': (pointingAtPos[0] - triangleSize) + 'px',
      'top': (pointingAtPos[1] + (pointingAtSize[1] / 2) - triangleSize) + 'px'
    })
  }
  else if (positionedWhere === 'top') {
    triangle.css({
      'left': (pointingAtPos[0] + (pointingAtSize[0] / 2) - (triangleSize)) + 'px',
      'top': (pointingAtPos[1] - triangleSize) + 'px'
    })
  }
  else if (positionedWhere === 'bottom') {
    triangle.css({
      'left': (pointingAtPos[0] + (pointingAtSize[0] / 2) - (triangleSize)) + 'px',
      'top': (pointingAtPos[1] + pointingAtSize[1] - triangleSize) + 'px'
    })
  }

  return triangle
}

export interface PositionReturn {
  // The triangle created if chosen, can use this to remove it when you're ready
  triangle?: JQuery,

  positioned: Edge | 'center'
}

function clamp(val: number, min: number, max: number) {
  return Math.min(Math.max(val, min), max)
}

/**
 * Position an element relative to another
 * @param element the element to position
 * @param relativeTo the element to use as an anchor
 */
function positionFixed(element: HTMLElement, relativeTo: HTMLElement, options?: PositionOptions): PositionReturn {
  options = _.extend({
    align: 0,
    where: ['bottom'],
    matchElementWidth: false,
    triangle: false,
    gutter: [10, 10, 10, 10],
    allowResize: false,
    parent: document
  }, options)

  options.gutter = typeof options.gutter === 'number' ? [options.gutter, options.gutter, options.gutter, options.gutter] : options.gutter
  options.where = Array.isArray(options.where) ? options.where : [options.where]

  function shouldBePositioned(where: string): boolean {
    return (options.where as string[]).indexOf(where) >= 0
  }
  function positionABeforeB(a: string, b: string): boolean {
    function indexOfNotMinus1(str: string) {
      const index = (options.where as string[]).indexOf(str)
      return index === -1 ? 99999 : index
    }
    return indexOfNotMinus1(a) < indexOfNotMinus1(b)
  }
  const edgeIndexMap: { [edge: string]: number } = {
    top: 0,
    right: 1,
    bottom: 2,
    left: 3
  }
  function gutterForEdge(edge: string) {
    return options.gutter[edgeIndexMap[edge]]
  }

  const $element = $(element)
  const $relativeTo = $(relativeTo)

  const elSize = [$element.outerWidth(), $element.outerHeight()]
  const relativeToSize = [$relativeTo.outerWidth(), $relativeTo.outerHeight()]
  const relativeToViewportPos = viewportPosition($relativeTo, options.parent)
  const cssProps: any = {
    position: 'fixed'
  }
  const returnMe: PositionReturn = {} as any

  function positionLeftRight(cameFromAboveBelow: boolean = false): void {

    const minTop = options.gutter[0]
    const maxTop = window.innerHeight - options.gutter[2] - elSize[1]

    let topPos = relativeToViewportPos[1] + (relativeToSize[1] * options.align) - (elSize[1] * options.align)
    topPos = clamp(topPos, minTop, maxTop) // don't go out of the viewport bounds

    const relativeToMaxX = (relativeToViewportPos[0] + relativeToSize[0])
    const spaceToTheRight = window.innerWidth - relativeToMaxX
    const spaceToTheLeft = relativeToViewportPos[0]

    let fellBackToCentering: boolean = false
    let isToLeft: boolean = false

    if (spaceToTheLeft >= elSize[0]) {
      // if there's enough space on the left, position it there
      cssProps.top = topPos + 'px'
      cssProps.right = (window.innerWidth - relativeToViewportPos[0]) + 'px'
      isToLeft = true
    } else {
      // if not, try the right
      if (spaceToTheRight < elSize[0]) {
        // not enough space? position above or below
        if (!cameFromAboveBelow) {
          return positionAboveBelow()
        }
        else {
          // center the darn thing, no space
          cssProps.top = window.innerHeight / 2 - elSize[1] / 2
          cssProps.left = window.innerWidth / 2 - elSize[0] / 2
          fellBackToCentering = true
        }
      }
      else {
        // there's enough space! :)
        cssProps.top = topPos + 'px'
        cssProps.left = (relativeToViewportPos[0] + relativeToSize[0]) + 'px'
      }
    }

    if (options.triangle && !fellBackToCentering) {
      returnMe.triangle = addTriangleToFixedElement($element, isToLeft ? 'left' : 'right', $relativeTo, $element.parent())
    }

    let positioned: Edge | 'center' = isToLeft ? 'left' : 'right'
    if (fellBackToCentering) {
      positioned = 'center'
    }
    returnMe.positioned = positioned
  }

  function positionAboveBelow(): void {

    const minLeft = options.gutter[3]
    const maxLeft = window.innerWidth - options.gutter[1] - elSize[0]

    let leftPos = relativeToViewportPos[0] + (relativeToSize[0] * options.align) - (elSize[0] * options.align)
    leftPos = clamp(leftPos, minLeft, maxLeft) // don't go out of the viewport bounds

    const relativeToMaxY = (relativeToViewportPos[1] + relativeToSize[1])
    const spaceAbuv = relativeToViewportPos[1]
    const spaceBelow = window.innerHeight - relativeToMaxY

    let isAbove: boolean = false
    if (options.matchElementWidth) {
      if (typeof options.matchElementWidth === 'boolean') {
        cssProps.width = relativeToSize[0] + 'px'
      } else if (typeof options.matchElementWidth === 'number') {
        cssProps.width = options.matchElementWidth + 'px'
      } else {
        cssProps.width = $(options.matchElementWidth).outerWidth() + 'px'
      }
    }

    // if it's too big, and we allow resize, enforce the size before positioning
    if (spaceAbuv < elSize[1] && spaceBelow < elSize[1] && options.allowResize) {
      if (positionABeforeB('bottom', 'top')) {
        const gutter = gutterForEdge('bottom')
        elSize[1] = (spaceBelow - gutter)
        cssProps.height = elSize[1] + 'px'
      }
      else {
        const gutter = gutterForEdge('top')
        elSize[1] = (spaceAbuv - gutter)
        cssProps.height = elSize[1] + 'px'
      }
    }

    function above() {
      if (spaceAbuv < elSize[1]) {
        // if not enough room, fail
        return false
      }
      cssProps.left = leftPos + 'px'
      cssProps.bottom = (window.innerHeight - relativeToViewportPos[1]) + 'px'
      isAbove = true
      return true
    }

    function below() {
      if (spaceBelow < elSize[1]) {
        // if not enough room, fail
        return false
      }
      cssProps.left = leftPos + 'px'
      cssProps.top = (relativeToViewportPos[1] + relativeToSize[1]) + 'px'
      return true
    }

    const positionAttempts = positionABeforeB('bottom', 'top')
      ? [below, above, function () { return positionLeftRight(true) }]
      : [above, below, function () { return positionLeftRight(true) }]

    for (let i = 0; i < positionAttempts.length; i++) {
      const success = positionAttempts[i]()
      if (success) {
        break;
      }
    }

    if (options.triangle) {
      returnMe.triangle = addTriangleToFixedElement($element, isAbove ? 'top' : 'bottom', $relativeTo, $element.parent())
    }

    returnMe.positioned = isAbove ? 'top' : 'bottom'
  }

  if (shouldBePositioned('bottom') || shouldBePositioned('top')) {
    positionAboveBelow()
  }
  else {
    positionLeftRight()
  }

  // Hide any elements where CSS position variant doesn't match position of element
  const { positionVariantSelector } = options
  if (positionVariantSelector) {
    const positions = ['top', 'right', 'bottom', 'left']

    positions.forEach(function stripElements(position): void {
      const variantElement = $(`${positionVariantSelector}.-${position}`)

      if (variantElement.length && (returnMe.positioned === position)) {
        variantElement.remove()
      }
    })
  }

  $element.css(cssProps)
  return returnMe
}
