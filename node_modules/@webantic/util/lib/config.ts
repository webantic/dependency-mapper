/// <reference path="../typings/index.d.ts" />
/** @module util/config */

// @ts-check
import { assert } from './meteor'
import { didResolve } from './object'

export {
  Configuration
}

/**
 * A configuration class - provides a DB-backed, environment variable / meteor.settings populated set of config values
 *
 * @param {Mongo.Collection} collection the config collection
 * @param {Object} Meteor a reference to the Meteor object
 * @param {Object} [Tracker] an optional reference to Tracker - will be mocked in a non-reactive way if not supplied
 * @param {Object} [connection] an optional override for the DDP connection to use to subscribe to the config pub
 * @class Configuration
 */
class Configuration {
  items: { [key: string]: any }
  dependency: Tracker.Dependency
  Meteor: any
  connection: DDP.DDPStatic
  _collection: Mongo.Collection<any>
  _cursor: Mongo.Cursor<any>
  _observer: Meteor.LiveQueryHandle

  constructor({ collection, Meteor, Tracker, connection }: config.ICtorParams) {
    assert(collection, 'Missing collection in Configuration constructor')
    assert(Meteor, 'Missing reference to Meteor in Configuration constructor')

    // in-memory store of config values
    this.items = {}

    // tracker dep
    this.dependency = Tracker ? new Tracker.Dependency() : this._trackerMock()

    // ref to Meteor
    this.Meteor = Meteor

    // DB store
    this._collection = collection

    // DDP connection for pub/sub
    // this.connection = connection || (Meteor as any as DDP.DDPStatic)
    this._handlePubSub(connection)
  }

  /**
   * An internal function to provide a default Tracker object (which does NOT support reactivity)
   *
   * @returns {Object} a mocked Tracker object
   * @memberof Configuration
   */
  _trackerMock(): Tracker.Dependency {
    return {
      depend: (fromComputation?: Tracker.Computation) => true,
      changed: () => { },
      hasDependents: () => false
    }
  }

  /**
   * An internal method to provide public configuration values to clients
   *
   * @param {any} cb A callback to be called when the subscription is ready
   *
   * @memberof Configuration
   */
  _handlePubSub(connection?: DDP.DDPStatic) {
    const callback = () => {
      if (this._observer) {
        this._observer.stop()
      }

      this._cursor = this._collection.find({})
      this._observer = this._getObserver(this._cursor)
    }

    if (this.Meteor.isServer) {
      this.Meteor.publish('__public_configuration', () => this._collection.find({ public: true }))
      callback()
    } else if (connection) {
      connection.subscribe('__public_configuration', {
        onReady: callback,
        onStop: callback
      })
    }
  }

  /**
   * A method to get a handle to an observer from a cursor
   *
   * @param {Mongo.Cursor} cursor
   * @returns handle to a observer
   *
   * @memberof Configuration
   */
  _getObserver(cursor: Mongo.Cursor<any>) {
    const self = this
    return cursor.observeChanges({
      added: function documentAddedHandler(id, fields: any) {
        fields.isPublic = fields.public
        self.addItem((Object as any).assign(fields, { added: true }))
      },
      changed: function documentChangedHandler(id, fields) {
        // this only works because the id is the same as the key,
        // meaning we don't have to have all the fields at hand here
        const doc = self._collection.findOne(id)
        doc.isPublic = doc.public
        self.set(id, (Object as any).assign(doc, { options: { isFromObserver: true } }))
      },
      removed: () => { /* no-op */ }
    })
  }

  /**
   * Check whether the type of something matches what is expected
   *
   * @param {any} type Either a constructor, or a string. To be checked against the result of `typeof`
   * @param {any} value The value to check
   * @returns {Boolean} whether the type matches
   *
   * @memberof Configuration
   */
  _checkType(type: Function | string, value: any): boolean {
    if (typeof type === 'function') {
      if (value instanceof type) {
        // instance check ( e.g. for `var str = new String("...` )
        return true
      }

      // turn `function String (...` into `"string"`
      type = (type as any).name.toLowerCase()
    }

    return typeof value === type
  }

  /**
   * Gets a value from process.env / meteor.settings or falls back to the one provided
   *
   * @param {any} key The key for the value
   * @param {any} value The default value
   * @returns {any}
   *
   * @memberof Configuration
   */
  _getValue(key: string, value?: any) {
    if (this.Meteor.isServer) {
      if (this._collection.findOne(key)) {
        value = this._collection.findOne(key).value
      }

      if (didResolve(process, `env.${key}`)) {
        try {
          value = JSON.parse(process.env[key])
        } catch (ex) {
          value = process.env[key]
        }
      }

      if (didResolve(this.Meteor, `settings.${key}`)) {
        value = this.Meteor.settings[key]
      }
    } else if (didResolve(this.Meteor, `settings.public.${key}`)) {
      value = this.Meteor.settings.public[key]
    }

    return value
  }

  /**
   * Adds a value to the in-memory store & upserts it to the db (unless overwrite is present and `false`)
   *
   * @param {any} { key, value, type, isPublic, overwrite, added }
   *
   * @memberof Configuration
   */
  addItem({ key, value, type, isPublic, isPrivileged, overwrite, added }: config.IAddItemParams) {
    if (type) {
      assert(type && this._checkType(type, value), `Type check failed: ${JSON.stringify({ key, type, value })}`)
    }

    value = this._getValue(key, value)
    if (this.Meteor.isServer) {
      isPublic = typeof isPublic === 'boolean' ? isPublic : false

      let typeStr = type
      if (typeof type === 'function') {
        typeStr = (type as any).name.toLowerCase()
      }

      const doc = {
        key,
        value,
        type: typeStr,
        public: isPublic,
        privileged: isPrivileged
      }

      if (overwrite !== false) {
        // upsert isn't working with autovalues
        if (this._collection.findOne(key)) {
          (this._collection.update as any)(key, { $set: doc }, { removeEmptyStrings: false })
        } else if (!added) {
          (doc as any)._id = key
            ; (this._collection.insert as any)(doc, { removeEmptyStrings: false })
        }
      }
    }

    const item = (Object as any).assign({ value, type }, this._collection.findOne({ key }) || {})
    this.items[key] = item
    this.dependency.changed()
  }

  /**
   * Gets the in-memory value for a given key
   *
   * @param {any} key
   * @returns {any} the value
   *
   * @memberof Configuration
   */
  get(key: string) {
    this.dependency.depend()
    return this.items[key] && this.items[key].value
  }

  /**
   * Update the in-memory value and stored value in the db
   *
   * @param {any} key
   * @param {any} { value, type, options }
   *
   * @memberof Configuration
   */
  set(key: string, { value, type, options }: config.ISetItemParams) {
    options = options || {}

    const item = this._collection.findOne({ key })
    if (!item) {
      return
    }

    type = type || item.type

    if (value) {
      const overrides: { value: any, type?: any } = { value }

      if (type) {
        overrides.type = type
        assert(this._checkType(type, value), `Type check failed: ${JSON.stringify({ key, type, value })}`)
      }

      if (this.Meteor.isServer && !options.isFromObserver && item.value.toString() !== value.toString()) {
        (this._collection.update as any)({
          _id: key
        }, {
            $set: { value }
          }, { removeEmptyStrings: false })
      }


      this.items[key] = (Object as any).assign(item, overrides)
      this.dependency.changed()
    }
  }
}
