"use strict";
/** @module util/popover */
exports.__esModule = true;
require("jquery");
var emitter_1 = require("./emitter");
var opposites = {
    top: 'bottom',
    bottom: 'top',
    left: 'right',
    right: 'left'
};
/**
 * Opens a popover with the specified content located on the edge of the source object
 * @param source the target element this popover should be attached to
 * @param content the content to show in the popover
 * @param options
 */
function open(source, $content, options) {
    var multiEmitter = new emitter_1.MultiEmitter();
    var $source = $(source);
    var $contentWrap = $('<div class="content">').append($($content));
    var closed = false;
    options = _.extend({
        matchElementWidth: true,
        xAlign: 0.5,
        css: '',
        overflow: false
    }, options);
    var additionalClasses = source.className.split(' ').map(function (c) {
        return '-popover-source-' + c;
    }).join(' ') + ' ' + (options.css || ''.trim());
    var clickCatch = $('<div id="popover-click-catch">').css({
        position: 'absolute',
        width: '100%',
        height: '100%',
        top: '0',
        left: '0'
    }).click(function (e) {
        if ($(e.target).attr('id') === 'popover-click-catch') {
            close();
        }
    });
    $contentWrap.addClass(additionalClasses);
    $contentWrap.css({
        position: 'absolute',
        display: 'none',
        width: options.matchElementWidth ? ($source.outerWidth() + 'px') : ''
    });
    // Add to DOM in order to perform size calculations and add blaze template etc.
    var wrap = $('<div>').addClass('popover-wrap').css({
        position: 'fixed',
        width: '100%',
        height: '100%',
        top: '0',
        left: '0'
    });
    wrap.append(clickCatch, $contentWrap);
    wrap = wrap.appendTo($('body'));
    $contentWrap.css({
        visibility: 'hidden',
        display: ''
    });
    var requiredHeight = $contentWrap.outerHeight();
    var viewportPos = viewportPosition($source);
    var elSize = [$source.outerWidth(), $source.outerHeight()];
    var leftPos = viewportPos[0] + (elSize[0] * options.xAlign) - ($contentWrap.outerWidth() * options.xAlign);
    if (options.dropdown) {
        options.overflow = false;
        var pad = 25;
        var totalHeight = void 0;
        if (options.overflow) {
            totalHeight = requiredHeight;
        }
        else {
            totalHeight = Math.min(500, requiredHeight, (window.innerHeight - 100) / 2);
        }
        var top_1 = (viewportPos[1] + elSize[1]);
        if (top_1 + totalHeight > window.innerHeight) {
            top_1 -= (elSize[1] + totalHeight);
        }
        $contentWrap.css({
            'left': leftPos + 'px',
            'top': top_1 + 'px',
            'overflow-y': options.overflow ? 'visible' : 'auto',
            'overflow-x': 'visible',
            'height': totalHeight
        });
    }
    else {
        $contentWrap.css({
            'left': leftPos + 'px',
            'top': Math.min(viewportPos[1] + elSize[1]) + 'px'
        });
    }
    if (options.matchElementWidth) {
        $contentWrap.css({
            'width': elSize[0] + 'px'
        });
    }
    $contentWrap.removeClass('-above').addClass('-below');
    $contentWrap.css({
        visibility: ''
    });
    $source.addClass('-popover-open');
    function close() {
        if (closed) {
            return;
        }
        $source.removeClass('-popover-open');
        wrap.remove();
        closed = true;
        multiEmitter.broadcast('close');
    }
    $(window).on('resize.dropdown', close);
    return {
        events: multiEmitter,
        popover: $contentWrap,
        close: close
    };
}
exports.open = open;
/**
 * Opens a dropdown, which internally is still a popover with some special additions
 * @param source which element should the dropdown be attached to?
 * @param dropDownItems the items that should be shown in the dropdown @see DropDownItem
 * @param options
 */
function openDropdown($source, dropDownItems, options) {
    var dropDownItemsGetter = dropDownItems;
    if (typeof (dropDownItems) !== 'function') {
        dropDownItemsGetter = function () {
            return dropDownItems;
        };
    }
    if (!dropDownItemsGetter().length) {
        return console.warn('Tried to open an empty dropdown');
    }
    var dropDown = $("<div class=\"dropdown\"></div>");
    var hasSubMenus = false;
    function addScrollClass(element) {
        var normal = $(element)[0];
        var canScroll = (normal.offsetHeight < normal.scrollHeight) && element.scrollTop() === 0;
        $(element).toggleClass('-can-scroll', canScroll);
    }
    function addScrollHandlers(element) {
        $(element).scroll(function () {
            addScrollClass(element);
        });
    }
    function positionSubMenu(subMenu, parent) {
        var css = {
            position: 'fixed',
            top: '',
            bottom: '',
            overflow: '',
            maxHeight: ''
        };
        subMenu.css(css);
        var parentMenu = $(parent).parent();
        var parentLeft = $(parentMenu).offset().left - $(window).scrollLeft();
        var parentItem = parent;
        var parentItemTop = $(parentItem).offset().top - $(window).scrollTop();
        var parentItemHeight = $(parentItem).outerHeight();
        var parentItemMidY = parentItemTop + parentItemHeight / 2;
        var top = parentItemMidY - $(subMenu).outerHeight() / 2;
        var bottom = top + $(subMenu).outerHeight();
        function bottomSpace() {
            return window.innerHeight - 25 - bottom;
        }
        function topSpace() {
            return top - 25;
        }
        if (topSpace() < 0) {
            var topSpaceNow = topSpace();
            // move down
            top -= topSpaceNow;
            bottom -= topSpaceNow;
        }
        if (bottomSpace() < 0) {
            // going over on the bottom now? clip
            bottom += bottomSpace();
        }
        css = {
            position: 'fixed',
            top: top + 'px',
            bottom: (window.innerHeight - bottom) + 'px',
            overflow: 'auto',
            maxHeight: '95vh'
        };
        var spaceOnRight = window.innerWidth -
            (parentMenu.offset().left + parentMenu.outerWidth());
        var hasSpaceOnRight = spaceOnRight >= subMenu.outerWidth();
        if (hasSpaceOnRight) {
            css['left'] = (parentLeft + $(parentMenu).width()) + 'px';
        }
        else {
            css['right'] = (window.innerWidth - parentLeft) + 'px';
        }
        subMenu.css(css);
        addScrollClass(subMenu);
    }
    function htmlForItem(item) {
        if (typeof (item) === 'string') {
            if (item[0] === '_') {
                return $("<div class=" + item.substr(1) + ">");
            }
            return $("<div class='heading'>" + item + "</div>");
        }
        var html = $("<div class=\"item\">" + item.name + "</div>").click(function (e) {
            // No click action on sub items
            if (!item.items && typeof (item.action) === 'function') {
                var clicked_1 = $(e.currentTarget);
                clicked_1.addClass('-clicked');
                var flash = function () { return clicked_1.addClass('-flashing'); };
                var unflash = function () { return clicked_1.removeClass('-flashing'); };
                var ops_1 = [flash, unflash, flash, function () {
                        popoverResult.close();
                    }, item.action];
                var process_1 = function () {
                    if (ops_1.length > 0) {
                        setTimeout(function () {
                            ops_1.shift()();
                            process_1();
                        }, 75);
                    }
                };
                process_1();
            }
        }).hover(function (over) {
            html.addClass('-dropdown-hovering');
            if ($(this).children('.subMenu').length) {
                positionSubMenu($(this).children('.subMenu'), this);
            }
        }, function (out) {
            if ($(this).closest('-dropdown-hovering').length === 0) {
                html.removeClass('-dropdown-hovering');
            }
        }).addClass(item.css || '');
        if (item.items && item.items.length > 0) {
            hasSubMenus = true;
            var subMenu_1 = $("<div class=\"subMenu\">");
            item.items.forEach(function (subItem) {
                subMenu_1.append(htmlForItem(subItem));
            });
            subMenu_1.appendTo(html);
            addScrollHandlers(subMenu_1);
            html.addClass('-has-subMenu');
        }
        return html;
    }
    dropDownItemsGetter().forEach(function (item) { return dropDown.append(htmlForItem(item)); });
    addScrollHandlers(dropDown);
    var popoverResult = open($source, dropDown, _.extend({}, options, {
        dropdown: true,
        // A limitation in our implementation stops it being possible from having submenus AND
        // overflow: scroll, because overflow-y: auto implies overflow-x: auto too :(
        overflow: hasSubMenus
    }));
    addScrollClass(dropDown);
    function getSelected() {
        return popoverResult.popover.find('.item.-selected');
    }
    return {
        popover: popoverResult,
        close: popoverResult.close,
        up: function () {
            ifLet([getSelected().prev('.item')[0]], function (prev) {
                getSelected().removeClass('-selected');
                $(prev).addClass('-selected');
            }, function () {
                getSelected().removeClass('-selected');
                popoverResult.popover.find('.item').last().addClass('-selected');
            });
        },
        down: function () {
            ifLet([getSelected().next('.item')[0]], function (next) {
                getSelected().removeClass('-selected');
                $(next).addClass('-selected');
            }, function () {
                getSelected().removeClass('-selected');
                popoverResult.popover.find('.item').first().addClass('-selected');
            });
        },
        acceptSelected: function () {
            getSelected().removeClass('-selected').trigger('click');
        }
    };
}
exports.openDropdown = openDropdown;
/**
 * Internal function used to run a specific callback with a value if it exists
 * @param toCheck the value, or values to check
 * @param ifCallback the callback to run with the value if it exists
 * @param elseCallback the callback to run if the value does not exist
 */
function ifLet(toCheck, ifCallback, elseCallback) {
    if (!Array.isArray(toCheck)) {
        toCheck = [toCheck];
    }
    if (toCheck.every(function (arg) { return arg !== null && arg !== undefined; })) {
        return ifCallback.apply(this, toCheck);
    }
    else if (elseCallback) {
        return elseCallback();
    }
}
/**
 * Internal function used to get the viewport position of an element
 * @param element
 */
function viewportPosition(element, parent) {
    if (parent === void 0) { parent = document; }
    return [
        $(element).offset().left - $(parent).scrollLeft(),
        $(element).offset().top - $(parent).scrollTop()
    ];
}
/**
 * Adds a triangle to point at the edge of one element (element) to a target (pointingAt)
 * @param element the element doing the pointing
 * @param positionedWhere where is the popup in relation to the target
 * @param pointingAt what should it point at
 * @param container where do we add the triangle
 * @returns the triangle element
 */
function addTriangleToFixedElement(element, positionedWhere, pointingAt, container) {
    if (container === void 0) { container = $('body'); }
    var triangleSize = 15;
    var triangleSizeStr = triangleSize + 'px';
    var triangleCss = (_a = {
            position: 'fixed',
            top: '100%',
            height: 0,
            width: 0,
            borderTop: "solid " + triangleSizeStr + " transparent",
            borderBottom: "solid " + triangleSizeStr + " transparent",
            borderLeft: "solid " + triangleSizeStr + " transparent",
            borderRight: "solid " + triangleSizeStr + " transparent"
        },
        _a["border-" + positionedWhere + "-color"] = 'white',
        _a);
    var triangle = $('<div>').addClass('popover-triangle').css(triangleCss).appendTo(container);
    element.css('margin-' + opposites[positionedWhere], triangleSizeStr);
    var pointingAtPos = viewportPosition(pointingAt);
    var pointingAtSize = [pointingAt.outerWidth(), pointingAt.outerHeight()];
    if (positionedWhere === 'right') {
        triangle.css({
            'left': (pointingAtPos[0] + pointingAtSize[0] - triangleSize) + 'px',
            'top': (pointingAtPos[1] + (pointingAtSize[1] / 2) - triangleSize) + 'px'
        });
    }
    else if (positionedWhere === 'left') {
        triangle.css({
            'left': (pointingAtPos[0] - triangleSize) + 'px',
            'top': (pointingAtPos[1] + (pointingAtSize[1] / 2) - triangleSize) + 'px'
        });
    }
    else if (positionedWhere === 'top') {
        triangle.css({
            'left': (pointingAtPos[0] + (pointingAtSize[0] / 2) - (triangleSize)) + 'px',
            'top': (pointingAtPos[1] - triangleSize) + 'px'
        });
    }
    else if (positionedWhere === 'bottom') {
        triangle.css({
            'left': (pointingAtPos[0] + (pointingAtSize[0] / 2) - (triangleSize)) + 'px',
            'top': (pointingAtPos[1] + pointingAtSize[1] - triangleSize) + 'px'
        });
    }
    return triangle;
    var _a;
}
function clamp(val, min, max) {
    return Math.min(Math.max(val, min), max);
}
/**
 * Position an element relative to another
 * @param element the element to position
 * @param relativeTo the element to use as an anchor
 */
function positionFixed(element, relativeTo, options) {
    options = _.extend({
        align: 0,
        where: ['bottom'],
        matchElementWidth: false,
        triangle: false,
        gutter: [10, 10, 10, 10],
        allowResize: false,
        parent: document
    }, options);
    options.gutter = typeof options.gutter === 'number' ? [options.gutter, options.gutter, options.gutter, options.gutter] : options.gutter;
    options.where = Array.isArray(options.where) ? options.where : [options.where];
    function shouldBePositioned(where) {
        return options.where.indexOf(where) >= 0;
    }
    function positionABeforeB(a, b) {
        function indexOfNotMinus1(str) {
            var index = options.where.indexOf(str);
            return index === -1 ? 99999 : index;
        }
        return indexOfNotMinus1(a) < indexOfNotMinus1(b);
    }
    var edgeIndexMap = {
        top: 0,
        right: 1,
        bottom: 2,
        left: 3
    };
    function gutterForEdge(edge) {
        return options.gutter[edgeIndexMap[edge]];
    }
    var $element = $(element);
    var $relativeTo = $(relativeTo);
    var elSize = [$element.outerWidth(), $element.outerHeight()];
    var relativeToSize = [$relativeTo.outerWidth(), $relativeTo.outerHeight()];
    var relativeToViewportPos = viewportPosition($relativeTo, options.parent);
    var cssProps = {
        position: 'fixed'
    };
    var returnMe = {};
    function positionLeftRight(cameFromAboveBelow) {
        if (cameFromAboveBelow === void 0) { cameFromAboveBelow = false; }
        var minTop = options.gutter[0];
        var maxTop = window.innerHeight - options.gutter[2] - elSize[1];
        var topPos = relativeToViewportPos[1] + (relativeToSize[1] * options.align) - (elSize[1] * options.align);
        topPos = clamp(topPos, minTop, maxTop); // don't go out of the viewport bounds
        var relativeToMaxX = (relativeToViewportPos[0] + relativeToSize[0]);
        var spaceToTheRight = window.innerWidth - relativeToMaxX;
        var spaceToTheLeft = relativeToViewportPos[0];
        var fellBackToCentering = false;
        var isToLeft = false;
        if (spaceToTheLeft >= elSize[0]) {
            // if there's enough space on the left, position it there
            cssProps.top = topPos + 'px';
            cssProps.right = (window.innerWidth - relativeToViewportPos[0]) + 'px';
            isToLeft = true;
        }
        else {
            // if not, try the right
            if (spaceToTheRight < elSize[0]) {
                // not enough space? position above or below
                if (!cameFromAboveBelow) {
                    return positionAboveBelow();
                }
                else {
                    // center the darn thing, no space
                    cssProps.top = window.innerHeight / 2 - elSize[1] / 2;
                    cssProps.left = window.innerWidth / 2 - elSize[0] / 2;
                    fellBackToCentering = true;
                }
            }
            else {
                // there's enough space! :)
                cssProps.top = topPos + 'px';
                cssProps.left = (relativeToViewportPos[0] + relativeToSize[0]) + 'px';
            }
        }
        if (options.triangle && !fellBackToCentering) {
            returnMe.triangle = addTriangleToFixedElement($element, isToLeft ? 'left' : 'right', $relativeTo, $element.parent());
        }
        var positioned = isToLeft ? 'left' : 'right';
        if (fellBackToCentering) {
            positioned = 'center';
        }
        returnMe.positioned = positioned;
    }
    function positionAboveBelow() {
        var minLeft = options.gutter[3];
        var maxLeft = window.innerWidth - options.gutter[1] - elSize[0];
        var leftPos = relativeToViewportPos[0] + (relativeToSize[0] * options.align) - (elSize[0] * options.align);
        leftPos = clamp(leftPos, minLeft, maxLeft); // don't go out of the viewport bounds
        var relativeToMaxY = (relativeToViewportPos[1] + relativeToSize[1]);
        var spaceAbuv = relativeToViewportPos[1];
        var spaceBelow = window.innerHeight - relativeToMaxY;
        var isAbove = false;
        if (options.matchElementWidth) {
            if (typeof options.matchElementWidth === 'boolean') {
                cssProps.width = relativeToSize[0] + 'px';
            }
            else if (typeof options.matchElementWidth === 'number') {
                cssProps.width = options.matchElementWidth + 'px';
            }
            else {
                cssProps.width = $(options.matchElementWidth).outerWidth() + 'px';
            }
        }
        // if it's too big, and we allow resize, enforce the size before positioning
        if (spaceAbuv < elSize[1] && spaceBelow < elSize[1] && options.allowResize) {
            if (positionABeforeB('bottom', 'top')) {
                var gutter = gutterForEdge('bottom');
                elSize[1] = (spaceBelow - gutter);
                cssProps.height = elSize[1] + 'px';
            }
            else {
                var gutter = gutterForEdge('top');
                elSize[1] = (spaceAbuv - gutter);
                cssProps.height = elSize[1] + 'px';
            }
        }
        function above() {
            if (spaceAbuv < elSize[1]) {
                // if not enough room, fail
                return false;
            }
            cssProps.left = leftPos + 'px';
            cssProps.bottom = (window.innerHeight - relativeToViewportPos[1]) + 'px';
            isAbove = true;
            return true;
        }
        function below() {
            if (spaceBelow < elSize[1]) {
                // if not enough room, fail
                return false;
            }
            cssProps.left = leftPos + 'px';
            cssProps.top = (relativeToViewportPos[1] + relativeToSize[1]) + 'px';
            return true;
        }
        var positionAttempts = positionABeforeB('bottom', 'top')
            ? [below, above, function () { return positionLeftRight(true); }]
            : [above, below, function () { return positionLeftRight(true); }];
        for (var i = 0; i < positionAttempts.length; i++) {
            var success = positionAttempts[i]();
            if (success) {
                break;
            }
        }
        if (options.triangle) {
            returnMe.triangle = addTriangleToFixedElement($element, isAbove ? 'top' : 'bottom', $relativeTo, $element.parent());
        }
        returnMe.positioned = isAbove ? 'top' : 'bottom';
    }
    if (shouldBePositioned('bottom') || shouldBePositioned('top')) {
        positionAboveBelow();
    }
    else {
        positionLeftRight();
    }
    // Hide any elements where CSS position variant doesn't match position of element
    var positionVariantSelector = options.positionVariantSelector;
    if (positionVariantSelector) {
        var positions = ['top', 'right', 'bottom', 'left'];
        positions.forEach(function stripElements(position) {
            var variantElement = $(positionVariantSelector + ".-" + position);
            if (variantElement.length && (returnMe.positioned === position)) {
                variantElement.remove();
            }
        });
    }
    $element.css(cssProps);
    return returnMe;
}
exports.positionFixed = positionFixed;
//# sourceMappingURL=popover.js.map