/** @module util/object */

const isset = didResolve
const deepSet = resolveSet
const deepSetP = resolveSetP

export {
  map,
  filter,
  resolve,
  didResolve,
  isset,
  resolveIf,
  resolveSet,
  deepSet,
  resolveSetP,
  deepSetP,
  flatten,
  transform,
  transformPathsToObjects,
  forEach
}

/**
 * @function map
 * @export
 * @summary passes each key=>value pair to `callback`,
 * setting the result to a new object under a key of
 * the same name
 * @param {any} object the object whose values to map
 * @param {Function} callback a
 * function to pass each key=>value pair to
 * @returns {any} a new object with the same key names
 * but mapped values
 */
function map(object: any, callback: (key: string, value: any) => any): any {
  let result: any = {}

  function eachKey(key: string, value: any): void {
    if (object.hasOwnProperty(key)) {
      let element = callback(key, object[key])

      result[key] = element
    }
  }

  for (let key in object) {
    eachKey(key, object[key])
  }

  return result
}

/**
 * @function transform
 * @summary Like map, but able to transform the key too. Map the object into a completely
 * different
 * @param object the object to transform
 * @param callback callback to perform the transformation, return an array like [key, value]
 */
function transform<T>(object: any, callback: (key: string, value: T) => [string, T]) {
  const result: any = {}
  Object.keys(object).forEach(function (key: string) {
    const keyAndValue = callback(key, object[key])
    if (Array.isArray(keyAndValue)) {
      result[keyAndValue[0]] = keyAndValue[1]
    }
  })
  return result
}

/**
 * @function forEach
 * @summary Like array.forEach, but for an object, gets keys and values
 */
function forEach<T>(object: any, callback: (key: string, value: T) => any | [string, T]) {
  Object.keys(object).forEach(function (key: string) {
    callback(key, object[key])
  })
}

/**
 * @function filter
 * @export
 * @summary passes each key=>value pair of an object
 * to `callback`, copying them over if the result is
 * truthy
 * @param {any} object the object whose keys to filter
 * @param {Function} callback the
 * function to pass each key=>value pair to
 * @returns {any} a filtered copy of the input object
 */
function filter(object: any, callback: (key: string, value: any) => any): any {
  let result: any = {}

  function eachKey(key: string, value: any): void {
    if (callback(key, value)) {
      // if callback is truthy, copy the key=>value pair over
      result[key] = object[key]
    }
  }

  for (let key in object) {
    eachKey(key, object[key])
  }

  return result
}

/**
 * @function resolve
 * @export
 * @summary get a nested property of an object by string e.g. resolve(myObj, 'nested.property')
 * @returns {any|undefined} resolved value or undefined if intermediate values are undefined
 */
function resolve(obj: any, path: string, options: { default?: any } = {}): any {
  if (!obj) {
    return undefined
  }
  const ret = path
    .split('.')
    .reduce(function reducePath(prev, curr) {
      return (typeof prev === 'object') ? prev[curr] : undefined
    }, obj)
  if (options.default != null && ret == null) {
    return options.default
  }
  return ret
}

/**
 * @function didResolve
 * @export
 * @alias isset
 * @summary report whether an attempt to resolve a nested property of an object
 * was successful or not.
 * @returns {boolean} whether the nested property exists
 */
function didResolve(obj: any, path: string): boolean {
  let parts = path.split('.')
  let deepestKey = parts.pop()

  if (!obj) {
    return false
  }

  if (parts.length === 0) {
    return deepestKey in obj
  } else {
    let res = parts.reduce(function reducePath(prev, curr) {
      return (typeof prev === 'object') ? prev[curr] : undefined
    }, obj)
    return res && deepestKey in res
      ? true
      : false
  }
}

/**
 * @function resolveIf
 * @export
 * @summary same as resolve but sets the property to val
 * @returns {any|null} The resolved value or null
 */
function resolveIf(obj: any, path: string, testCallback: (value: any) => any): any {
  let resolved = resolve(obj, path)
  if (resolved !== undefined && resolved !== null && testCallback(resolved)) {
    return resolved
  }
  return null
}

export interface ResolveSetOptions {
  /**
   * If true, won't overwrite existing values
   * Defaults to false
   */
  noOverwrite?: boolean,

  /**
   * If true, will turn something.0.field into an array element
   * Defaults to false
   */
  makeArrays?: boolean,

  /**
   * If true, will turn something.field into an object if it doesn't exist
   */
  makeObjects?: boolean
}

/**
 * @function resolveSet
 * @export
 * @alias deepSet
 * @summary same as resolve but sets the property to val
 * @return {boolean} whether setting was successful
 */
function resolveSet(obj: any, path: string, val: any, options: ResolveSetOptions = {}): any {
  let components = path.split('.')

  while (components.length > 0) {
    if (typeof obj !== 'object') {
      break
    }

    if (components.length === 1) {
      // we're at the last component, the part where we actually set the value
      const lastComponent = components[0]
      if (options.makeArrays && Array.isArray(obj)) {
        const index = parseInt(lastComponent)
        while (index >= obj.length) {
          obj.push(null)
        }
      }

      if (obj[lastComponent] && options.noOverwrite) {
        // if there's a truthy value and we're not allowed to overwrite, return false
        return false
      }
      obj[lastComponent] = val
      return true
    } else {
      // still more of the path to go down
      const nextComponent = components.shift()
      const nextNextComponent = components[0]

      // if the next field is numeric, prepare by making an array if there isn't one
      if (options.makeArrays && !isNaN(parseInt(nextNextComponent)) && !Array.isArray(obj[nextComponent])) {
        obj[nextComponent] = []
      }
      else if (options.makeObjects && typeof obj[nextComponent] !== 'object') {
        obj[nextComponent] = {}
      }
      obj = obj[nextComponent]
    }
  }

  return false
}

/**
 * Transform an entire object by converting all of its keys into object paths using resolveSet
 * @param obj the object to transform (transformed in place)
 * @returns obj for convenience, although transformed in place
 */
function transformPathsToObjects(obj: any): any {
  Object.keys(obj).forEach(function (key) {
    // convert all 'something.something' into nested fields
    if (!didResolve(obj, key)) {
      resolveSet(obj, key, obj[key], { makeArrays: true, makeObjects: true })
      delete obj[key]
    }
  })
  return obj
}

/**
 * Convert a deep object into one which is flat (has a max depth of 1 level). The output object's keys will
 * use dot notation to symbolise depth.
 *
 * @param {object} input An input object. Required
 * @param {object} _output Private param used in recursion
 * @param {string} _prefix Private param used in recursion
 *
 * @example
 *
 *     var deepObj = {person: {profile: {name: 'Carl', age: 26}, password: 'foobar'}}
 *     flatten(deepObj)
 *     // returns {'person.profile.name': 'Carl', 'person.profile.age': 26, 'person.password': 'foobar'}
 *
 */
function flatten(input: { [key: string]: any }, _output: { [key: string]: any }, _prefix?: string) {
  _output = _output || {}
  for (let key in input) {
    if (typeof input[key] === 'object' && input[key] !== null && !(input[key] instanceof Array)) {
      flatten(input[key], _output, _prefix ? _prefix + '.' + key : key)
    } else {
      _output[_prefix ? _prefix + '.' + key : key] = input[key]
    }
  }

  return _output
}

/**
 * @function resolveSetP
 * @export
 * @alias deepSetP
 * @summary same as resolveSet, but will create paths down into
 * objects where they don't exist
 * @param obj {object} the object to create the value in
 * @param path {string} the path (dot notation) into the object
 * @param val {any} the new value
 * @returns {boolean} whether the op was successful
 */
function resolveSetP(obj: any, path: string, val: any): object | boolean {
  function _resolveSetP(obj: any, path: string, val: any): object | boolean {
    const parts = path.split('.')
    const firstPart = parts.shift()

    if (obj === undefined) {
      // If `obj` is undefined, set it to an empty object - useful in recursive
      // situations where `obj[key]` is undefined
      obj = isNaN(Number(firstPart)) ? {} : []
    } else if (obj === null || typeof obj !== 'object') {
      // If `obj` is already set to some value that isn't an object, fail instead
      // of overwriting existing data
      return false
    }

    // If the path down into the object already exists, use resolveSet instead
    if (didResolve(obj, path)) {
      return resolveSet(obj, path, val)
    }

    // `parts.length` could legitimately be 0 because we just shifted out the first
    // part. If, however, there was more than one part to begin with, recurse
    if (parts.length > 0) {
      // recurse, using `obj[firstPart]` as the new `obj` - for non-existant
      // paths, this will be `undefined` and caught by the `if` statement at the
      // start of this function
      const res = _resolveSetP(obj[firstPart], parts.join('.'), val)
      if (typeof res === 'boolean') {
        // allow successes/failures to pass back up the call stack
        return res
      }
      // set `obj[firstPart]` to the returned object
      obj[firstPart] = res
    } else {
      // We are at the deepest required level, set the value of `obj[firstPart]`
      // to `val`
      obj[firstPart] = val
    }

    // if we're down here then we're in a recursive scenario, return the computed
    // inner object back up the call stack
    return obj
  }

  const res = _resolveSetP(obj, path, val)
  if (typeof res === 'boolean') {
    return res
  } else {
    return true
  }
}

