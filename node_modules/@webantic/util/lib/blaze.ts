/** @module util/blaze */

declare const Promise: any

import * as _ from 'underscore'
let metaCollection: Mongo.Collection<any> = null

/**
 * Attach a DDP connection to Blaze so that it is available in templates' `this.subscribe`
 *
 * @param {Object} Blaze a reference to Blaze
 * @param {Object} API The DDP connection to attachs
 */
function attachAPI(Blaze: any, API: Meteor.Connection) {
  const Template = Blaze.Template
  if (Blaze.TemplateInstance.prototype.api) {
    // already attached
    return
  }

  const globalActiveMethods = new ReactiveVar<{ [method: string]: number }>({})
  function incDecIsCallingMethod(name: string, amount: number, reactiveVar = globalActiveMethods) {

    const curr = reactiveVar.get()
    if (amount <= 0 && !curr[name]) {
      return
    }
    if (!curr[name]) {
      curr[name] = amount
    }
    else {
      curr[name] += amount
    }

    if (curr[name] <= 0) {
      delete curr[name]
    }
    reactiveVar.set(curr)
  }

  function makeOnReadyOnStopObject(args: any[]) {
    const defaultHandlers = {
      onReady() { },
      onStop() { }
    }
    const last = args[args.length - 1]
    if (typeof last === 'function') {
      args[args.length - 1] = {
        onStop() { },
        onReady() {
          last()
        }
      }
    }
    else if (!last || typeof last !== 'object' || (!last.onReady && !last.onStop)) {
      args.push(defaultHandlers)
    }

    const lastArg = args[args.length - 1]
    // Incase we had onReady but not onStop or the other way round, make sure we have both
    if (!lastArg.onStop) {
      lastArg.onStop = function () { }
    }
    if (!lastArg.onReady) {
      lastArg.onReady = function () { }
    }

    // Ensure consistent behaviour by forcing async onReady / onStop callbacks
    // get some nasty bugs if these are sometimes called synchronously - consider this:
    // `const sub = this.api.subscribe('something', function onReady () { console.log(sub.subscriptionId) })`
    // throws a ReferenceError - cannot read property "subscriptionId" of undefined. Because the `api.subscribe()`
    // func hasn't returned yet.
    const oldOnReady = lastArg.onReady
    const oldOnStop = lastArg.onStop
    lastArg.onReady = () => Meteor.defer(oldOnReady)
    lastArg.onStop = () => Meteor.defer(oldOnStop)

    return args
  }

  function cleanupApiSubscriptionsOnDestroy() {
    (this.__apiSubscriptions || []).forEach(function (subscription: Meteor.SubscriptionHandle) {
      subscription.stop()
    })
  }

  Blaze.TemplateInstance.prototype.api = {
    connection: API,
    _init: function () {
      const template = Template.instance() || this
      if (!template.__apiInit) {
        template.__apiDependency = new Tracker.Dependency()
        template.__apiInit = true
        template.__metaCollections = {}
        template.__callingMethods = new ReactiveVar({})
        template.autorun(function (handle: Tracker.Computation) {
          handle.onStop(function () {
            cleanupApiSubscriptionsOnDestroy.apply(template)
          })
        })
      }
    },
    subscribeAndCount: function (...args: any[]) {
      const template = Template.instance() || this
      template.api._init.call(template)

      let stopped = false
      args = makeOnReadyOnStopObject(args)
      let existing = args[args.length - 1].onStop || function () { }
      args[args.length - 1].onStop = function () {
        stopped = true
        existing()
      }

      let onCountChanged: Function = function () { }
      let currentCount = 0
      const { subscriptionId } = template.api.subscribe(...args)
      if (!metaCollection) {
        metaCollection = new Mongo.Collection('webantic_subscriptionMeta')
      }

      template.autorun(function (handle: any) {
        if (stopped) {
          handle.stop()
        }
        const currentMeta = metaCollection.findOne(subscriptionId) as any
        if (currentMeta) {
          currentCount = currentMeta.count
          onCountChanged(currentMeta.count)
        }
      })

      return {
        /**
         * Add a function to get called when the count changes
         * @param callback {function}
         */
        onCountChanged(callback: any) {
          onCountChanged = callback
          callback(currentCount)
        },
        subscriptionId
      }
    },
    subscribe: function (...args: any[]) {
      const template = Template.instance() || this
      template.api._init.call(template)

      args = makeOnReadyOnStopObject(args)
      const lastArg = args.pop()
      const options = {
        onReady: lastArg.onReady,
        onStop() {
          template.__apiSubscriptions = template.__apiSubscriptions.filter(function (subscriptionObject: any) {
            return subscriptionObject.subscriptionId !== result.subscriptionId
          })

          // remove any refs to the meta collection (keeps things tidy and prevents memory leaks)
          delete (API as any)._stores[metaCollectionName]

          template.__apiDependency.changed()
          lastArg.onStop.apply(arguments)
        }
      }
      const result = (API as any).subscribe(...args, options)

      // keep track of this subscription so we can tell when the subscriptions are ready
      template.__apiSubscriptions = template.__apiSubscriptions || []
      template.__apiSubscriptions.push(result)

      // track the meta collection if not already tracked so we can tidy up after ourselves
      const subscriptionName = args[0]
      const { subscriptionId } = result
      const metaCollectionName = `${subscriptionName}_${subscriptionId}` // e.g. 'pens_rcKQkhKy38JdM5H5G'
      if (!(metaCollectionName in template.__metaCollections)) {
        // create the new collection and pass in the correct connection object
        template.__metaCollections[metaCollectionName] = new Mongo.Collection(metaCollectionName, API as any)
      }

      // provide a convenience property on the returned object
      result.meta = template.__metaCollections[metaCollectionName]

      // remove this subscription from the array when it's stopped
      template.__apiDependency.changed()
      return result
    },
    subscriptionsReady: function () {
      const template = Template.instance() || this
      template.api._init.call(template)
      template.__apiDependency.depend()

      return (template.__apiSubscriptions || []).every(function (subscription: Meteor.SubscriptionHandle) {
        return subscription.ready()
      })
    },
    /**
     * @param methodName the method to check, if null, checks if the api is calling any method at all
     * @param global whether to check if the api is calling a method globally or just on this template
     */
    isCalling: function (methodName?: string, global: boolean = false): boolean {
      const reactiveVar = global ? globalActiveMethods : (Template.instance() || this).__callingMethods
      if (!methodName) {
        return Object.keys(reactiveVar.get()).length > 0
      }
      return reactiveVar.get()[methodName] != null
    },
    quietly: function (func: Function) {
      this.quietMode = true
      func()
      this.quietMode = false
    },
    call: function (...args: any[]) {
      const templateInstance = Template.instance() || this
      const api = templateInstance.api
      api._init.call(templateInstance)

      let givenCallback: Function | null
      if (typeof args[args.length - 1] === 'function') {
        givenCallback = args.pop()
      }
      const methodName = args[0]
      if (!methodName || typeof methodName !== 'string') {
        console.warn(methodName + ' is not a method')
      }
      return new Promise(function (resolve: Function, reject: Function) {
        let ourCallback = function (error: Meteor.Error, result: any) {
          if (!api.quietMode) {
            incDecIsCallingMethod(args[0], -1)
            incDecIsCallingMethod(args[0], -1, templateInstance.__callingMethods)
          }

          if (givenCallback) {
            givenCallback(error, result)
          }
          if (error) {
            reject(error)
          }
          else {
            resolve(result)
          }
        }
        if (!api.quietMode) {
          incDecIsCallingMethod(args[0], 1)
          incDecIsCallingMethod(args[0], 1, templateInstance.__callingMethods)
        }
        ; (API as any).call.apply(API, args.concat(ourCallback))
      })

    }
  }

  /**
   * @summary whether all subscriptions are ready, including those from the api
   * @returns {Boolean}
   */
  Template.registerHelper('subscriptionsReady', function () {
    return Template.instance().api.subscriptionsReady() && Template.instance().subscriptionsReady()
  })

  /**
   * @summary is the api calling a method right now on this template
   * @returns {Boolean}
   */
  Template.registerHelper('apiCalling', function (global = false) {
    return Template.instance().api.isCalling(null, global)
  })
}

export {
  attachAPI
}
