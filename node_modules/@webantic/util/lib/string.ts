/// <reference path="../typings/globals/underscore/index.d.ts" />
/** @module util/string */

import * as _ from 'underscore'

const is = {
  email: isEmail,
  URL: isUrl,
  IP: isIP,
  IPv4: isIPv4,
  IPv6: isIPv6,
  nonEmpty,
  empty: () => !nonEmpty()
}

export {
  capitalize,
  humanize,
  titleize,
  camelize,
  hyphenate,
  truncate,
  addThousandsSeparators,
  extname,
  underscore,
  keyify,
  getDomain,
  startsWith,
  endsWith,
  escapeRegExp,
  caseInsensitivePermutations,
  is
}

/**
 * @function capitalize
 * @export
 * @summary makes the first letter of a string
 * uppercase and the rest lowercase
 * @param {string} str the string to capitalise
 * @returns {string} the capitalised string
 */
function capitalize(str: string): string {
  str = str || ''
  str = str.trim()

  if (str[0]) {
    str = str[0].toUpperCase() + str.substr(1).toLowerCase()
  }

  return str
}

/**
 * @function humanize
 * @export
 * @summary Converts identifiers to more human-friendly
 * versions. e.g. helloWorld -> Hello world
 * @param {string} str the string to humanise
 * @returns {string} the human-friendly version of the
 * string
 */
function humanize(str: string): string {
  // Ensure we have a value
  str = str || ''
  // Ensure string
  str = str.toString() // might be a number
  // Remove leading/trailing white-space
  str = str.trim()
  // Remove file extension
  str = str.replace(extname(str), '')
  // Standardise delimeters
  str = underscore(str).replace('-', '_')
  // Remove trailing underscores
  str = str.replace(/[\W_]+/g, ' ')
  // De-camelCase
  str = str.replace(/([a-z])([A-Z])/g, '$1 $2')

  return capitalize(str).trim()
}

/**
 * @function titleize
 * @export
 * @summary converts each words' first letter
 * to uppercase.
 * @param {string} str the string to titleize
 * @returns {string} the titleized string
 */
function titleize(str: string): string {
  if (str.length === 0) {
    return ''
  }

  return str.split(' ').map(capitalize).join(' ')
}

/**
 * @function camelize
 * @export
 * @summary converts a string of words to a lowerCamelCase word
 * @param {string} str the string to camelize
 * @returns {string} the camelized string
 */
function camelize(str: string) {
  return str.replace(/(?:^\w|[A-Z]|\b\w|\s+)/g, function (match: string, index) {
    if (+match === 0) return '' // or if (/\s+/.test(match)) for white spaces
    return index == 0 ? match.toLowerCase() : match.toUpperCase()
  })
}

/**
 * @function hyphenate
 * @export
 * @summary converts spaces to hyphens
 * @param {string} str the string to perform the
 * replacements on
 * @returns {string} the processed string
 */
function hyphenate(str: string): string {
  return str.replace(/ /g, '-')
}

/**
 * @function truncate
 * @export
 * @summary limits the length of a string to `count` (plus
 * three for dots)
 * @param {string} str the string to truncate
 * @param {number} [count] the maximum length of the string
 * @returns {string} the possibly truncated string
 */
function truncate(str: string, count?: number): string {
  count = typeof count === 'number' ? count : 10

  let words = str.split(' ')
  let output = ''

  function addWord(word: string): string {
    if (!word) {
      return output
    }

    if (output.length && count >= output.length + 1 + word.length) {
      output += ' ' + word
      addWord(words.shift())
    } else if (!output.length && count >= output.length + word.length) {
      output += word
      addWord(words.shift())
    } else {
      if (!output.length) {
        output += word[0]
      }
      output += '...'
    }

    return output
  }

  return addWord(words.shift())
}

/**
 * @function addThousandsSeparators
 * @export
 * @summary Inserts a comma every three digits
 * @param {string|number} str a number, represented
 * as a string
 * @returns {string} the formatted number
 */
function addThousandsSeparators(str: string): string {
  return str
    .toString()
    .replace(/\B(?=(\d{3})+(?!\d))/g, ',')
    .replace(',,', ',')
}

/**
 * @function extname
 * @export
 * @summary gets the file extension from a file name
 * @param {string} filename the full filename. e.g. "movie.avi"
 * @returns {string} the file extension
 */
function extname(filename: string): string {
  let index = filename.lastIndexOf('.')
  let ext = filename.substring(index, filename.length)

  return (index === -1) ? '' : ext
}

/**
 * @function underscore
 * @export
 * @summary converts spaces to underscores in a string
 * @param {string} str the string to process
 * @returns {string} the processed string
 */
function underscore(str: string): string {
  return str.replace(/ /g, '_')
}

/**
 * @function keyify
 * @export
 * @summary converts spaces to dashes/underscores &
 * lowercases the string for db values and filenames etc..
 * @param {string} str the string to keyify
 * @param {string} [replacer] the character to use in
 * place of spaces. Can be '-' or '_'
 * @returns {string} the keyified string
 */
function keyify(str: string, replacer: string): string {
  if (replacer === '_') {
    return underscore(str).toLowerCase()
  } else {
    return hyphenate(str).toLowerCase()
  }
}

/**
 * @function getDomain
 * @export
 * @summary gets the domain from an email address
 * @param {string} str the email address to test
 * @returns {string|null} the domain, or null
 */
function getDomain(str: string): string {
  let parsedDomain = require('parse-domain')(str || '')
  let parts = [parsedDomain.domain, parsedDomain.tld]

  if (parsedDomain.subdomain) {
    parts.unshift(parsedDomain.subdomain)
  }

  return parts.join('.')
}

/**
 * @function startsWith
 * @export
 * @summary Reports whether `haystack` starts with `needle`
 * @param {string} haystack the string to search
 * @param {string} needle the substring to search for
 * @returns {boolean} whether haystack starts with needle
 */
function startsWith(haystack: string, needle: string): boolean {
  return haystack && haystack.slice(0, needle.length) === needle
}

/**
 * @function endsWith
 * @export
 * @summary Reports whether `haystack` ends with `needle`
 * @param {string} haystack the string to search
 * @param {string} needle the substring to search for
 * @returns {boolean} whether haystack ends with needle
 */
function endsWith(haystack: string, needle: string): boolean {
  if (!haystack) {
    return false
  }

  let offset = haystack.length - needle.length
  return haystack.slice(offset) === needle
}

/**
 * @function escapeRegExp
 * @export
 * @summary Escapes special characters in a string, enabling
 * the string's use as a regex
 * @param {string} str the string to escape
 * @returns {string} the escaped string
 */
function escapeRegExp(str: string): string {
  return String(str).replace(/[.*+?^${}()|[\]\\]/g, '\\$&')
}

/**
 * @function isEmail
 * @export
 * @summary determines whether a string looks like
 * an email address
 * @param {string} str the potential email address
 * @returns {boolean} whether the string looks like an email
 */
function isEmail(str: string): boolean {
  const regEx = new RegExp('^(([^<>()\\[\\]\\\\.,;:\\s@"]+(\\.[^<>()\\[\\]\\\\.,;:\\s@"]+)*)|' +
    '(".+"))@((\\[[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}\\.[0-9]{1,3}])|(([a-zA-Z\\-0-9]+\\.)+[' +
    'a-zA-Z0-9]{2,}))$')
  return regEx.test(str)
}

/**
 * @function isUrl
 * @export
 * @summary determines whether a string looks like
 * a url
 * @param {string} str the potential url
 * @returns {boolean} whether the string looks like a url
 */
function isUrl(str: string): boolean {
  const regEx = new RegExp('^(?:(?:https?|ftp):\\/\\/)(?:\\S+(?::\\S*)?@)?(?:(?!(?:10|127)(?:\\.\\d{1' +
    ',3}){3})(?!(?:169\\.254|192\\.168)(?:\\.\\d{1,3}){2})(?!172\\.(?:1[6-9]|2\\d|3[0-1])(?:\\.\\d{1,' +
    '3}){2})(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:' +
    '[1-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)' +
    '(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})' +
    '))(?::\\d{2,5})?(?:[/?#]\\S*)?$', 'i')
  return regEx.test(str)
}

/**
 * @function isIP
 * @export
 * @summary determins whether a string looks like
 * an ip address (either IPv4 or IPv6)
 * @param {string} str the potential ip address
 * @returns {boolean} whether the string looks like an ip
 */
function isIP(str: string): boolean {
  return isIPv4(str) || isIPv6(str)
}

/**
 * @function isIPv4
 * @export
 * @summary determines whether a string looks like
 * an ip address
 * @param {string} str the potential ip address
 * @returns {boolean} whether the string looks like an ip
 */
function isIPv4(str: string): boolean {
  const regEx = /^(25[0-5]|2[0-4]\d|1\d\d|0?[0-9]?\d)(\.(25[0-5]|2[0-4]\d|1\d\d|0?[0-9]?\d)){3}$/
  return regEx.test(str)
}

/**
 * @function isIPv6
 * @export
 * @summary determines whether a string looks like
 * an ip address
 * @param {string} str the potential ip address
 * @returns {boolean} whether the string looks like an ip
 */
function isIPv6(str: string): boolean {
  const regEx = new RegExp('^\\s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:' +
    '){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[' +
    '1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]\\d|1' +
    '\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((' +
    ':[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[' +
    '0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4}' +
    ')|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d' +
    '\\d|[1-9]?\\d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,' +
    '4}){0,3}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3})' +
    ')|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|' +
    '2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:))|(:(((:[0-9A-F' +
    'a-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]?\\d)(\\.(25[0-5]' +
    '|2[0-4]\\d|1\\d\\d|[1-9]?\\d)){3}))|:)))(%.+)?\\s*$')
  return regEx.test(str)
}

/**
 * @function caseInsensitivePermutations
 * @export
 * @summary generates permutations of all case variations of a given string.
 * @param str {string} The string to get permutations of
 * @returns {string[]} an array of permutations
 */
function caseInsensitivePermutations(str: string): string[] {
  let permutations = ['']
  for (let i = 0; i < str.length; i++) {
    const ch = str.charAt(i)
    permutations = _.flatten(permutations.map(function mapPermutations(prefix) {
      const lowerCaseChar = ch.toLowerCase()
      const upperCaseChar = ch.toUpperCase()
      // Don't add unneccesary permutations when ch is not a letter
      if (lowerCaseChar === upperCaseChar) {
        return [prefix + ch]
      } else {
        return [prefix + lowerCaseChar, prefix + upperCaseChar]
      }
    }))
  }
  return permutations
}

function nonEmpty(str?: string | null): boolean {
  return typeof str === 'string' && str.length > 0
}
