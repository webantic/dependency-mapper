/** @module util/collection */

import * as string from './string'

export {
  insert,
  update,
  remove,
  caseInsensitiveSelector,
  selectorFromParams,
  getObserverHandlers
}

export interface IFailedOps {
  code: number,
  message: string,
  meta: any
}

export interface ICollectionReturn {
  succeeded: any[],
  failed: IFailedOps[],
  success: boolean
}

/**
 * @function insert
 * @export
 * @summary Inserts a number of `items` into the given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<object>} items the items to insert.
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no inserts failed
 * - succeeded:  {Array<object|number>} The new document or
 *   the result of the insert operation
 * - failed {Array<object>} An array of failed insert results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function insert(collection: any, items: Array<any>): ICollectionReturn {
  if (!(items instanceof Array)) {
    items = [items]
  }

  let successfulInserts: any[] = []
  let failedInserts: IFailedOps[] = []

  items.forEach(function processItems(item) {
    try {
      let id = collection.insert(item) || false
      let result = id

      if (!result) {
        throw new Error('unknown-error-prevented-insert')
      }

      successfulInserts.push(collection.findOne(item._id) || result)
    } catch (e) {
      failedInserts.push({ code: 500, message: 'unknown-error-prevented-insert', meta: item })
    }
  })

  return {
    success: failedInserts.length === 0,
    succeeded: successfulInserts,
    failed: failedInserts
  }
}

/**
 * @function update
 * @export
 * @summary Updates a number of `items` into the given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<object>} items the items to update. The _id field
 * is used as a selector, the rest of the object as the modifier
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no updates failed
 * - succeeded {Array<object|number>} The new document or
 *   the result of the update operation
 * - failed {Array<object>} An array of failed update results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function update(collection: any, items: Array<any>): ICollectionReturn {
  if (!(items instanceof Array)) {
    items = [items]
  }

  let successfulUpdates: any[] = []
  let failedUpdates: IFailedOps[] = []

  items.forEach(function processItems(item) {
    if (!item._id) {
      failedUpdates.push({ code: 404, message: 'item-not-found', meta: item })
    } else {
      try {
        let itemClone: any = {}
        for (let key in item) {
          if (item.hasOwnProperty(key) && key !== '_id') {
            itemClone[key] = item[key]
          }
        }
        let result = collection.update({ _id: item._id }, { $set: itemClone }) || false

        if (!result) {
          failedUpdates.push({ code: 404, message: 'item-not-found', meta: item })
        } else {
          successfulUpdates.push(collection.findOne(item._id) || result)
        }
      } catch (e) {
        failedUpdates.push({ code: 500, message: 'unknown-error-prevented-update', meta: item })
      }
    }
  })

  return {
    success: failedUpdates.length === 0,
    succeeded: successfulUpdates,
    failed: failedUpdates
  }
}

/**
 * @function remove
 * @export
 * @summary Remvoves a number of items by their _id from the
 * given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<string>} _ids the _ids of the items to remove.
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no inserts failed
 * - succeeded {Array<object|number>} The result of the
 *   remove operation
 * - failed {Array<object>} An array of failed removal results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function remove(collection: any, _ids: Array<string>): ICollectionReturn {
  if (!(_ids instanceof Array)) {
    _ids = [_ids]
  }

  let successfulRemovals: any[] = []
  let failedRemovals: IFailedOps[] = []

  _ids.forEach(function processIds(_id) {
    try {
      if (collection.remove({ _id: _id })) {
        successfulRemovals.push(_id)
      } else {
        failedRemovals.push({ code: 404, message: 'item-not-found', meta: _id })
      }
    } catch (ex) {
      failedRemovals.push({ code: 500, message: 'unknown-error-prevented-removal', meta: _id })
    }
  })

  // If this method is being invoked via HTTP, set the status code
  if (!failedRemovals.length && successfulRemovals.length && typeof this.setHttpStatusCode === 'function') {
    this.setHttpStatusCode(204)
  }

  return {
    success: failedRemovals.length === 0,
    succeeded: successfulRemovals,
    failed: failedRemovals
  }
}

/**
 * @function caseInsensitiveSelector
 * @export
 * @summary Generates a selector for a field which will perform a case-insensitive
 * lookup for the given value
 * @param fieldName {string} the name of the field to query
 * @param str {string} the value to query
 * @returns {object} the Mongo selector object
 */
function caseInsensitiveSelector(fieldName: string, str: string): object {
  // Performance seems to improve up to 4 prefix characters
  const prefix = str.substring(0, Math.min(str.length, 4))
  const permutations = string.caseInsensitivePermutations(prefix)
  const orClause = permutations.map(function mapPermutations(prefixPermutation) {
    return {
      [fieldName]: new RegExp('^' + string.escapeRegExp(prefixPermutation))
    }
  })
  return {
    $and: [
      {
        $or: orClause
      }, {
        [fieldName]: new RegExp('^' + string.escapeRegExp(str) + '$', 'i')
      }
    ]
  }
}

/**
 * @function selectorFromParams
 * @export
 * @summary Parses "skip", "limit", "sort", "before" and "since" into a selector and options object
 * @param {Object} { skip, limit, sort, before, since, createdOrUpdated, fields } An object containing any/all of the defined
 * keys. "createdOrUpdated" can be either "createdAt" (default) or "updatedAt". It determines what "before" and "since"
 * act upon
 * @returns {Object} { selector, options } The constructed selector & options objects
 */
function selectorFromParams({ skip, limit, sort, before, since, createdOrUpdated, fields }: any = {}) {
  function getDate(val: any) {
    let parsedDate = null
    if (val instanceof Date) {
      parsedDate = val
    } else if (typeof val === 'string' || typeof val === 'number') {
      if (!isNaN(new Date(val).getTime())) {
        parsedDate = new Date(val)
      }
    }
    return parsedDate as Date
  }

  // createdOrUpdated defaults to createdAt
  createdOrUpdated = createdOrUpdated === 'updated' ? 'updatedAt' : 'createdAt'

  const selector: { [k: string]: any } = {}
  const options: { [k: string]: any } = {}

  /*
    selector
  */
  if (before && getDate(before)) {
    selector[createdOrUpdated] = {
      $lte: getDate(before)
    }
  }
  if (since && getDate(since)) {
    if (typeof selector[createdOrUpdated] === 'object') {
      selector[createdOrUpdated].$gte = getDate(since)
    } else {
      selector[createdOrUpdated] = {
        $gte: getDate(since)
      }
    }
  }

  /*
    options
  */
  if (skip) {
    options.skip = skip
  }
  if (limit) {
    options.limit = limit
  }
  if (sort && typeof sort === 'object') {
    const safeSort: { [k: string]: any } = {}
    for (let key in sort) {
      if (key[0] !== '$' && typeof sort[key] === 'number') {
        safeSort[key] = sort[key]
      }
    }
    options.sort = sort
  }
  if (fields) {
    options.fields = {}
    for (let field in fields) {
      options.fields[field] = parseInt(fields[field], 10)
    }
  }

  return {
    selector,
    options
  }
}

export interface observeHandler {
  added(id: string, fields: any): void
  changed(id: string, fields: any): void
  removed(id: string): void
}

/**
 * @function getObserverHandlers
 * @export
 * @summary Returns a map of default observe callback handlers
 * @param {any} context The `this` context. It should contain `added`, `changed` and `removed` methods
 * @param {string} collection The name of the collection to add/change/remove documents to/from
 * @returns {Object} { added, changed, removed } The map of callback handlers
 */
function getObserverHandlers(context: any, collection: string): observeHandler {
  return {
    added(id, fields) {
      context.added(collection, id, fields)
    },
    changed(id, fields) {
      context.changed(collection, id, fields)
    },
    removed(id) {
      context.removed(collection, id)
    }
  }
}
