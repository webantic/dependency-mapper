/** @module util/object */
declare const isset: typeof didResolve;
declare const deepSet: typeof resolveSet;
declare const deepSetP: typeof resolveSetP;
export { map, filter, resolve, didResolve, isset, resolveIf, resolveSet, deepSet, resolveSetP, deepSetP, flatten, transform, transformPathsToObjects, forEach };
/**
 * @function map
 * @export
 * @summary passes each key=>value pair to `callback`,
 * setting the result to a new object under a key of
 * the same name
 * @param {any} object the object whose values to map
 * @param {Function} callback a
 * function to pass each key=>value pair to
 * @returns {any} a new object with the same key names
 * but mapped values
 */
declare function map(object: any, callback: (key: string, value: any) => any): any;
/**
 * @function transform
 * @summary Like map, but able to transform the key too. Map the object into a completely
 * different
 * @param object the object to transform
 * @param callback callback to perform the transformation, return an array like [key, value]
 */
declare function transform<T>(object: any, callback: (key: string, value: T) => [string, T]): any;
/**
 * @function forEach
 * @summary Like array.forEach, but for an object, gets keys and values
 */
declare function forEach<T>(object: any, callback: (key: string, value: T) => any | [string, T]): void;
/**
 * @function filter
 * @export
 * @summary passes each key=>value pair of an object
 * to `callback`, copying them over if the result is
 * truthy
 * @param {any} object the object whose keys to filter
 * @param {Function} callback the
 * function to pass each key=>value pair to
 * @returns {any} a filtered copy of the input object
 */
declare function filter(object: any, callback: (key: string, value: any) => any): any;
/**
 * @function resolve
 * @export
 * @summary get a nested property of an object by string e.g. resolve(myObj, 'nested.property')
 * @returns {any|undefined} resolved value or undefined if intermediate values are undefined
 */
declare function resolve(obj: any, path: string, options?: {
    default?: any;
}): any;
/**
 * @function didResolve
 * @export
 * @alias isset
 * @summary report whether an attempt to resolve a nested property of an object
 * was successful or not.
 * @returns {boolean} whether the nested property exists
 */
declare function didResolve(obj: any, path: string): boolean;
/**
 * @function resolveIf
 * @export
 * @summary same as resolve but sets the property to val
 * @returns {any|null} The resolved value or null
 */
declare function resolveIf(obj: any, path: string, testCallback: (value: any) => any): any;
export interface ResolveSetOptions {
    /**
     * If true, won't overwrite existing values
     * Defaults to false
     */
    noOverwrite?: boolean;
    /**
     * If true, will turn something.0.field into an array element
     * Defaults to false
     */
    makeArrays?: boolean;
    /**
     * If true, will turn something.field into an object if it doesn't exist
     */
    makeObjects?: boolean;
}
/**
 * @function resolveSet
 * @export
 * @alias deepSet
 * @summary same as resolve but sets the property to val
 * @return {boolean} whether setting was successful
 */
declare function resolveSet(obj: any, path: string, val: any, options?: ResolveSetOptions): any;
/**
 * Transform an entire object by converting all of its keys into object paths using resolveSet
 * @param obj the object to transform (transformed in place)
 * @returns obj for convenience, although transformed in place
 */
declare function transformPathsToObjects(obj: any): any;
/**
 * Convert a deep object into one which is flat (has a max depth of 1 level). The output object's keys will
 * use dot notation to symbolise depth.
 *
 * @param {object} input An input object. Required
 * @param {object} _output Private param used in recursion
 * @param {string} _prefix Private param used in recursion
 *
 * @example
 *
 *     var deepObj = {person: {profile: {name: 'Carl', age: 26}, password: 'foobar'}}
 *     flatten(deepObj)
 *     // returns {'person.profile.name': 'Carl', 'person.profile.age': 26, 'person.password': 'foobar'}
 *
 */
declare function flatten(input: {
    [key: string]: any;
}, _output: {
    [key: string]: any;
}, _prefix?: string): {
    [key: string]: any;
};
/**
 * @function resolveSetP
 * @export
 * @alias deepSetP
 * @summary same as resolveSet, but will create paths down into
 * objects where they don't exist
 * @param obj {object} the object to create the value in
 * @param path {string} the path (dot notation) into the object
 * @param val {any} the new value
 * @returns {boolean} whether the op was successful
 */
declare function resolveSetP(obj: any, path: string, val: any): object | boolean;
