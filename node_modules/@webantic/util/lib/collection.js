"use strict";
/** @module util/collection */
exports.__esModule = true;
var string = require("./string");
/**
 * @function insert
 * @export
 * @summary Inserts a number of `items` into the given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<object>} items the items to insert.
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no inserts failed
 * - succeeded:  {Array<object|number>} The new document or
 *   the result of the insert operation
 * - failed {Array<object>} An array of failed insert results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function insert(collection, items) {
    if (!(items instanceof Array)) {
        items = [items];
    }
    var successfulInserts = [];
    var failedInserts = [];
    items.forEach(function processItems(item) {
        try {
            var id = collection.insert(item) || false;
            var result = id;
            if (!result) {
                throw new Error('unknown-error-prevented-insert');
            }
            successfulInserts.push(collection.findOne(item._id) || result);
        }
        catch (e) {
            failedInserts.push({ code: 500, message: 'unknown-error-prevented-insert', meta: item });
        }
    });
    return {
        success: failedInserts.length === 0,
        succeeded: successfulInserts,
        failed: failedInserts
    };
}
exports.insert = insert;
/**
 * @function update
 * @export
 * @summary Updates a number of `items` into the given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<object>} items the items to update. The _id field
 * is used as a selector, the rest of the object as the modifier
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no updates failed
 * - succeeded {Array<object|number>} The new document or
 *   the result of the update operation
 * - failed {Array<object>} An array of failed update results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function update(collection, items) {
    if (!(items instanceof Array)) {
        items = [items];
    }
    var successfulUpdates = [];
    var failedUpdates = [];
    items.forEach(function processItems(item) {
        if (!item._id) {
            failedUpdates.push({ code: 404, message: 'item-not-found', meta: item });
        }
        else {
            try {
                var itemClone = {};
                for (var key in item) {
                    if (item.hasOwnProperty(key) && key !== '_id') {
                        itemClone[key] = item[key];
                    }
                }
                var result = collection.update({ _id: item._id }, { $set: itemClone }) || false;
                if (!result) {
                    failedUpdates.push({ code: 404, message: 'item-not-found', meta: item });
                }
                else {
                    successfulUpdates.push(collection.findOne(item._id) || result);
                }
            }
            catch (e) {
                failedUpdates.push({ code: 500, message: 'unknown-error-prevented-update', meta: item });
            }
        }
    });
    return {
        success: failedUpdates.length === 0,
        succeeded: successfulUpdates,
        failed: failedUpdates
    };
}
exports.update = update;
/**
 * @function remove
 * @export
 * @summary Remvoves a number of items by their _id from the
 * given `collection`
 * @param {Mongo.Collection} collection A Mongo.Collection
 * @param {Array<string>} _ids the _ids of the items to remove.
 * @returns {Object} An object with the following keys:
 * - success {boolean} whether no inserts failed
 * - succeeded {Array<object|number>} The result of the
 *   remove operation
 * - failed {Array<object>} An array of failed removal results
 *   with the following keys:
 *   - code {number} the error code
 *   - message {string} the error message
 *   - meta {any} any additional, contextual data about the error
 */
function remove(collection, _ids) {
    if (!(_ids instanceof Array)) {
        _ids = [_ids];
    }
    var successfulRemovals = [];
    var failedRemovals = [];
    _ids.forEach(function processIds(_id) {
        try {
            if (collection.remove({ _id: _id })) {
                successfulRemovals.push(_id);
            }
            else {
                failedRemovals.push({ code: 404, message: 'item-not-found', meta: _id });
            }
        }
        catch (ex) {
            failedRemovals.push({ code: 500, message: 'unknown-error-prevented-removal', meta: _id });
        }
    });
    // If this method is being invoked via HTTP, set the status code
    if (!failedRemovals.length && successfulRemovals.length && typeof this.setHttpStatusCode === 'function') {
        this.setHttpStatusCode(204);
    }
    return {
        success: failedRemovals.length === 0,
        succeeded: successfulRemovals,
        failed: failedRemovals
    };
}
exports.remove = remove;
/**
 * @function caseInsensitiveSelector
 * @export
 * @summary Generates a selector for a field which will perform a case-insensitive
 * lookup for the given value
 * @param fieldName {string} the name of the field to query
 * @param str {string} the value to query
 * @returns {object} the Mongo selector object
 */
function caseInsensitiveSelector(fieldName, str) {
    // Performance seems to improve up to 4 prefix characters
    var prefix = str.substring(0, Math.min(str.length, 4));
    var permutations = string.caseInsensitivePermutations(prefix);
    var orClause = permutations.map(function mapPermutations(prefixPermutation) {
        return _a = {},
            _a[fieldName] = new RegExp('^' + string.escapeRegExp(prefixPermutation)),
            _a;
        var _a;
    });
    return {
        $and: [
            {
                $or: orClause
            },
            (_a = {},
                _a[fieldName] = new RegExp('^' + string.escapeRegExp(str) + '$', 'i'),
                _a)
        ]
    };
    var _a;
}
exports.caseInsensitiveSelector = caseInsensitiveSelector;
/**
 * @function selectorFromParams
 * @export
 * @summary Parses "skip", "limit", "sort", "before" and "since" into a selector and options object
 * @param {Object} { skip, limit, sort, before, since, createdOrUpdated, fields } An object containing any/all of the defined
 * keys. "createdOrUpdated" can be either "createdAt" (default) or "updatedAt". It determines what "before" and "since"
 * act upon
 * @returns {Object} { selector, options } The constructed selector & options objects
 */
function selectorFromParams(_a) {
    var _b = _a === void 0 ? {} : _a, skip = _b.skip, limit = _b.limit, sort = _b.sort, before = _b.before, since = _b.since, createdOrUpdated = _b.createdOrUpdated, fields = _b.fields;
    function getDate(val) {
        var parsedDate = null;
        if (val instanceof Date) {
            parsedDate = val;
        }
        else if (typeof val === 'string' || typeof val === 'number') {
            if (!isNaN(new Date(val).getTime())) {
                parsedDate = new Date(val);
            }
        }
        return parsedDate;
    }
    // createdOrUpdated defaults to createdAt
    createdOrUpdated = createdOrUpdated === 'updated' ? 'updatedAt' : 'createdAt';
    var selector = {};
    var options = {};
    /*
      selector
    */
    if (before && getDate(before)) {
        selector[createdOrUpdated] = {
            $lte: getDate(before)
        };
    }
    if (since && getDate(since)) {
        if (typeof selector[createdOrUpdated] === 'object') {
            selector[createdOrUpdated].$gte = getDate(since);
        }
        else {
            selector[createdOrUpdated] = {
                $gte: getDate(since)
            };
        }
    }
    /*
      options
    */
    if (skip) {
        options.skip = skip;
    }
    if (limit) {
        options.limit = limit;
    }
    if (sort && typeof sort === 'object') {
        var safeSort = {};
        for (var key in sort) {
            if (key[0] !== '$' && typeof sort[key] === 'number') {
                safeSort[key] = sort[key];
            }
        }
        options.sort = sort;
    }
    if (fields) {
        options.fields = {};
        for (var field in fields) {
            options.fields[field] = parseInt(fields[field], 10);
        }
    }
    return {
        selector: selector,
        options: options
    };
}
exports.selectorFromParams = selectorFromParams;
/**
 * @function getObserverHandlers
 * @export
 * @summary Returns a map of default observe callback handlers
 * @param {any} context The `this` context. It should contain `added`, `changed` and `removed` methods
 * @param {string} collection The name of the collection to add/change/remove documents to/from
 * @returns {Object} { added, changed, removed } The map of callback handlers
 */
function getObserverHandlers(context, collection) {
    return {
        added: function (id, fields) {
            context.added(collection, id, fields);
        },
        changed: function (id, fields) {
            context.changed(collection, id, fields);
        },
        removed: function (id) {
            context.removed(collection, id);
        }
    };
}
exports.getObserverHandlers = getObserverHandlers;
//# sourceMappingURL=collection.js.map