"use strict";
/** @module util/object */
exports.__esModule = true;
var isset = didResolve;
exports.isset = isset;
var deepSet = resolveSet;
exports.deepSet = deepSet;
var deepSetP = resolveSetP;
exports.deepSetP = deepSetP;
/**
 * @function map
 * @export
 * @summary passes each key=>value pair to `callback`,
 * setting the result to a new object under a key of
 * the same name
 * @param {any} object the object whose values to map
 * @param {Function} callback a
 * function to pass each key=>value pair to
 * @returns {any} a new object with the same key names
 * but mapped values
 */
function map(object, callback) {
    var result = {};
    function eachKey(key, value) {
        if (object.hasOwnProperty(key)) {
            var element = callback(key, object[key]);
            result[key] = element;
        }
    }
    for (var key in object) {
        eachKey(key, object[key]);
    }
    return result;
}
exports.map = map;
/**
 * @function transform
 * @summary Like map, but able to transform the key too. Map the object into a completely
 * different
 * @param object the object to transform
 * @param callback callback to perform the transformation, return an array like [key, value]
 */
function transform(object, callback) {
    var result = {};
    Object.keys(object).forEach(function (key) {
        var keyAndValue = callback(key, object[key]);
        if (Array.isArray(keyAndValue)) {
            result[keyAndValue[0]] = keyAndValue[1];
        }
    });
    return result;
}
exports.transform = transform;
/**
 * @function forEach
 * @summary Like array.forEach, but for an object, gets keys and values
 */
function forEach(object, callback) {
    Object.keys(object).forEach(function (key) {
        callback(key, object[key]);
    });
}
exports.forEach = forEach;
/**
 * @function filter
 * @export
 * @summary passes each key=>value pair of an object
 * to `callback`, copying them over if the result is
 * truthy
 * @param {any} object the object whose keys to filter
 * @param {Function} callback the
 * function to pass each key=>value pair to
 * @returns {any} a filtered copy of the input object
 */
function filter(object, callback) {
    var result = {};
    function eachKey(key, value) {
        if (callback(key, value)) {
            // if callback is truthy, copy the key=>value pair over
            result[key] = object[key];
        }
    }
    for (var key in object) {
        eachKey(key, object[key]);
    }
    return result;
}
exports.filter = filter;
/**
 * @function resolve
 * @export
 * @summary get a nested property of an object by string e.g. resolve(myObj, 'nested.property')
 * @returns {any|undefined} resolved value or undefined if intermediate values are undefined
 */
function resolve(obj, path, options) {
    if (options === void 0) { options = {}; }
    if (!obj) {
        return undefined;
    }
    var ret = path
        .split('.')
        .reduce(function reducePath(prev, curr) {
        return (typeof prev === 'object') ? prev[curr] : undefined;
    }, obj);
    if (options["default"] != null && ret == null) {
        return options["default"];
    }
    return ret;
}
exports.resolve = resolve;
/**
 * @function didResolve
 * @export
 * @alias isset
 * @summary report whether an attempt to resolve a nested property of an object
 * was successful or not.
 * @returns {boolean} whether the nested property exists
 */
function didResolve(obj, path) {
    var parts = path.split('.');
    var deepestKey = parts.pop();
    if (!obj) {
        return false;
    }
    if (parts.length === 0) {
        return deepestKey in obj;
    }
    else {
        var res = parts.reduce(function reducePath(prev, curr) {
            return (typeof prev === 'object') ? prev[curr] : undefined;
        }, obj);
        return res && deepestKey in res
            ? true
            : false;
    }
}
exports.didResolve = didResolve;
/**
 * @function resolveIf
 * @export
 * @summary same as resolve but sets the property to val
 * @returns {any|null} The resolved value or null
 */
function resolveIf(obj, path, testCallback) {
    var resolved = resolve(obj, path);
    if (resolved !== undefined && resolved !== null && testCallback(resolved)) {
        return resolved;
    }
    return null;
}
exports.resolveIf = resolveIf;
/**
 * @function resolveSet
 * @export
 * @alias deepSet
 * @summary same as resolve but sets the property to val
 * @return {boolean} whether setting was successful
 */
function resolveSet(obj, path, val, options) {
    if (options === void 0) { options = {}; }
    var components = path.split('.');
    while (components.length > 0) {
        if (typeof obj !== 'object') {
            break;
        }
        if (components.length === 1) {
            // we're at the last component, the part where we actually set the value
            var lastComponent = components[0];
            if (options.makeArrays && Array.isArray(obj)) {
                var index = parseInt(lastComponent);
                while (index >= obj.length) {
                    obj.push(null);
                }
            }
            if (obj[lastComponent] && options.noOverwrite) {
                // if there's a truthy value and we're not allowed to overwrite, return false
                return false;
            }
            obj[lastComponent] = val;
            return true;
        }
        else {
            // still more of the path to go down
            var nextComponent = components.shift();
            var nextNextComponent = components[0];
            // if the next field is numeric, prepare by making an array if there isn't one
            if (options.makeArrays && !isNaN(parseInt(nextNextComponent)) && !Array.isArray(obj[nextComponent])) {
                obj[nextComponent] = [];
            }
            else if (options.makeObjects && typeof obj[nextComponent] !== 'object') {
                obj[nextComponent] = {};
            }
            obj = obj[nextComponent];
        }
    }
    return false;
}
exports.resolveSet = resolveSet;
/**
 * Transform an entire object by converting all of its keys into object paths using resolveSet
 * @param obj the object to transform (transformed in place)
 * @returns obj for convenience, although transformed in place
 */
function transformPathsToObjects(obj) {
    Object.keys(obj).forEach(function (key) {
        // convert all 'something.something' into nested fields
        if (!didResolve(obj, key)) {
            resolveSet(obj, key, obj[key], { makeArrays: true, makeObjects: true });
            delete obj[key];
        }
    });
    return obj;
}
exports.transformPathsToObjects = transformPathsToObjects;
/**
 * Convert a deep object into one which is flat (has a max depth of 1 level). The output object's keys will
 * use dot notation to symbolise depth.
 *
 * @param {object} input An input object. Required
 * @param {object} _output Private param used in recursion
 * @param {string} _prefix Private param used in recursion
 *
 * @example
 *
 *     var deepObj = {person: {profile: {name: 'Carl', age: 26}, password: 'foobar'}}
 *     flatten(deepObj)
 *     // returns {'person.profile.name': 'Carl', 'person.profile.age': 26, 'person.password': 'foobar'}
 *
 */
function flatten(input, _output, _prefix) {
    _output = _output || {};
    for (var key in input) {
        if (typeof input[key] === 'object' && input[key] !== null && !(input[key] instanceof Array)) {
            flatten(input[key], _output, _prefix ? _prefix + '.' + key : key);
        }
        else {
            _output[_prefix ? _prefix + '.' + key : key] = input[key];
        }
    }
    return _output;
}
exports.flatten = flatten;
/**
 * @function resolveSetP
 * @export
 * @alias deepSetP
 * @summary same as resolveSet, but will create paths down into
 * objects where they don't exist
 * @param obj {object} the object to create the value in
 * @param path {string} the path (dot notation) into the object
 * @param val {any} the new value
 * @returns {boolean} whether the op was successful
 */
function resolveSetP(obj, path, val) {
    function _resolveSetP(obj, path, val) {
        var parts = path.split('.');
        var firstPart = parts.shift();
        if (obj === undefined) {
            // If `obj` is undefined, set it to an empty object - useful in recursive
            // situations where `obj[key]` is undefined
            obj = isNaN(Number(firstPart)) ? {} : [];
        }
        else if (obj === null || typeof obj !== 'object') {
            // If `obj` is already set to some value that isn't an object, fail instead
            // of overwriting existing data
            return false;
        }
        // If the path down into the object already exists, use resolveSet instead
        if (didResolve(obj, path)) {
            return resolveSet(obj, path, val);
        }
        // `parts.length` could legitimately be 0 because we just shifted out the first
        // part. If, however, there was more than one part to begin with, recurse
        if (parts.length > 0) {
            // recurse, using `obj[firstPart]` as the new `obj` - for non-existant
            // paths, this will be `undefined` and caught by the `if` statement at the
            // start of this function
            var res_1 = _resolveSetP(obj[firstPart], parts.join('.'), val);
            if (typeof res_1 === 'boolean') {
                // allow successes/failures to pass back up the call stack
                return res_1;
            }
            // set `obj[firstPart]` to the returned object
            obj[firstPart] = res_1;
        }
        else {
            // We are at the deepest required level, set the value of `obj[firstPart]`
            // to `val`
            obj[firstPart] = val;
        }
        // if we're down here then we're in a recursive scenario, return the computed
        // inner object back up the call stack
        return obj;
    }
    var res = _resolveSetP(obj, path, val);
    if (typeof res === 'boolean') {
        return res;
    }
    else {
        return true;
    }
}
exports.resolveSetP = resolveSetP;
//# sourceMappingURL=object.js.map