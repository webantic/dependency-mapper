"use strict";
/** @module util/blaze */
exports.__esModule = true;
var metaCollection = null;
/**
 * Attach a DDP connection to Blaze so that it is available in templates' `this.subscribe`
 *
 * @param {Object} Blaze a reference to Blaze
 * @param {Object} API The DDP connection to attachs
 */
function attachAPI(Blaze, API) {
    var Template = Blaze.Template;
    if (Blaze.TemplateInstance.prototype.api) {
        // already attached
        return;
    }
    var globalActiveMethods = new ReactiveVar({});
    function incDecIsCallingMethod(name, amount, reactiveVar) {
        if (reactiveVar === void 0) { reactiveVar = globalActiveMethods; }
        var curr = reactiveVar.get();
        if (amount <= 0 && !curr[name]) {
            return;
        }
        if (!curr[name]) {
            curr[name] = amount;
        }
        else {
            curr[name] += amount;
        }
        if (curr[name] <= 0) {
            delete curr[name];
        }
        reactiveVar.set(curr);
    }
    function makeOnReadyOnStopObject(args) {
        var defaultHandlers = {
            onReady: function () { },
            onStop: function () { }
        };
        var last = args[args.length - 1];
        if (typeof last === 'function') {
            args[args.length - 1] = {
                onStop: function () { },
                onReady: function () {
                    last();
                }
            };
        }
        else if (!last || typeof last !== 'object' || (!last.onReady && !last.onStop)) {
            args.push(defaultHandlers);
        }
        var lastArg = args[args.length - 1];
        // Incase we had onReady but not onStop or the other way round, make sure we have both
        if (!lastArg.onStop) {
            lastArg.onStop = function () { };
        }
        if (!lastArg.onReady) {
            lastArg.onReady = function () { };
        }
        // Ensure consistent behaviour by forcing async onReady / onStop callbacks
        // get some nasty bugs if these are sometimes called synchronously - consider this:
        // `const sub = this.api.subscribe('something', function onReady () { console.log(sub.subscriptionId) })`
        // throws a ReferenceError - cannot read property "subscriptionId" of undefined. Because the `api.subscribe()`
        // func hasn't returned yet.
        var oldOnReady = lastArg.onReady;
        var oldOnStop = lastArg.onStop;
        lastArg.onReady = function () { return Meteor.defer(oldOnReady); };
        lastArg.onStop = function () { return Meteor.defer(oldOnStop); };
        return args;
    }
    function cleanupApiSubscriptionsOnDestroy() {
        (this.__apiSubscriptions || []).forEach(function (subscription) {
            subscription.stop();
        });
    }
    Blaze.TemplateInstance.prototype.api = {
        connection: API,
        _init: function () {
            var template = Template.instance() || this;
            if (!template.__apiInit) {
                template.__apiDependency = new Tracker.Dependency();
                template.__apiInit = true;
                template.__metaCollections = {};
                template.__callingMethods = new ReactiveVar({});
                template.autorun(function (handle) {
                    handle.onStop(function () {
                        cleanupApiSubscriptionsOnDestroy.apply(template);
                    });
                });
            }
        },
        subscribeAndCount: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var template = Template.instance() || this;
            template.api._init.call(template);
            var stopped = false;
            args = makeOnReadyOnStopObject(args);
            var existing = args[args.length - 1].onStop || function () { };
            args[args.length - 1].onStop = function () {
                stopped = true;
                existing();
            };
            var onCountChanged = function () { };
            var currentCount = 0;
            var subscriptionId = (_a = template.api).subscribe.apply(_a, args).subscriptionId;
            if (!metaCollection) {
                metaCollection = new Mongo.Collection('webantic_subscriptionMeta');
            }
            template.autorun(function (handle) {
                if (stopped) {
                    handle.stop();
                }
                var currentMeta = metaCollection.findOne(subscriptionId);
                if (currentMeta) {
                    currentCount = currentMeta.count;
                    onCountChanged(currentMeta.count);
                }
            });
            return {
                /**
                 * Add a function to get called when the count changes
                 * @param callback {function}
                 */
                onCountChanged: function (callback) {
                    onCountChanged = callback;
                    callback(currentCount);
                },
                subscriptionId: subscriptionId
            };
            var _a;
        },
        subscribe: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var template = Template.instance() || this;
            template.api._init.call(template);
            args = makeOnReadyOnStopObject(args);
            var lastArg = args.pop();
            var options = {
                onReady: lastArg.onReady,
                onStop: function () {
                    template.__apiSubscriptions = template.__apiSubscriptions.filter(function (subscriptionObject) {
                        return subscriptionObject.subscriptionId !== result.subscriptionId;
                    });
                    // remove any refs to the meta collection (keeps things tidy and prevents memory leaks)
                    delete API._stores[metaCollectionName];
                    template.__apiDependency.changed();
                    lastArg.onStop.apply(arguments);
                }
            };
            var result = (_a = API).subscribe.apply(_a, args.concat([options]));
            // keep track of this subscription so we can tell when the subscriptions are ready
            template.__apiSubscriptions = template.__apiSubscriptions || [];
            template.__apiSubscriptions.push(result);
            // track the meta collection if not already tracked so we can tidy up after ourselves
            var subscriptionName = args[0];
            var subscriptionId = result.subscriptionId;
            var metaCollectionName = subscriptionName + "_" + subscriptionId; // e.g. 'pens_rcKQkhKy38JdM5H5G'
            if (!(metaCollectionName in template.__metaCollections)) {
                // create the new collection and pass in the correct connection object
                template.__metaCollections[metaCollectionName] = new Mongo.Collection(metaCollectionName, API);
            }
            // provide a convenience property on the returned object
            result.meta = template.__metaCollections[metaCollectionName];
            // remove this subscription from the array when it's stopped
            template.__apiDependency.changed();
            return result;
            var _a;
        },
        subscriptionsReady: function () {
            var template = Template.instance() || this;
            template.api._init.call(template);
            template.__apiDependency.depend();
            return (template.__apiSubscriptions || []).every(function (subscription) {
                return subscription.ready();
            });
        },
        /**
         * @param methodName the method to check, if null, checks if the api is calling any method at all
         * @param global whether to check if the api is calling a method globally or just on this template
         */
        isCalling: function (methodName, global) {
            if (global === void 0) { global = false; }
            var reactiveVar = global ? globalActiveMethods : (Template.instance() || this).__callingMethods;
            if (!methodName) {
                return Object.keys(reactiveVar.get()).length > 0;
            }
            return reactiveVar.get()[methodName] != null;
        },
        quietly: function (func) {
            this.quietMode = true;
            func();
            this.quietMode = false;
        },
        call: function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            var templateInstance = Template.instance() || this;
            var api = templateInstance.api;
            api._init.call(templateInstance);
            var givenCallback;
            if (typeof args[args.length - 1] === 'function') {
                givenCallback = args.pop();
            }
            var methodName = args[0];
            if (!methodName || typeof methodName !== 'string') {
                console.warn(methodName + ' is not a method');
            }
            return new Promise(function (resolve, reject) {
                var ourCallback = function (error, result) {
                    if (!api.quietMode) {
                        incDecIsCallingMethod(args[0], -1);
                        incDecIsCallingMethod(args[0], -1, templateInstance.__callingMethods);
                    }
                    if (givenCallback) {
                        givenCallback(error, result);
                    }
                    if (error) {
                        reject(error);
                    }
                    else {
                        resolve(result);
                    }
                };
                if (!api.quietMode) {
                    incDecIsCallingMethod(args[0], 1);
                    incDecIsCallingMethod(args[0], 1, templateInstance.__callingMethods);
                }
                ;
                API.call.apply(API, args.concat(ourCallback));
            });
        }
    };
    /**
     * @summary whether all subscriptions are ready, including those from the api
     * @returns {Boolean}
     */
    Template.registerHelper('subscriptionsReady', function () {
        return Template.instance().api.subscriptionsReady() && Template.instance().subscriptionsReady();
    });
    /**
     * @summary is the api calling a method right now on this template
     * @returns {Boolean}
     */
    Template.registerHelper('apiCalling', function (global) {
        if (global === void 0) { global = false; }
        return Template.instance().api.isCalling(null, global);
    });
}
exports.attachAPI = attachAPI;
//# sourceMappingURL=blaze.js.map