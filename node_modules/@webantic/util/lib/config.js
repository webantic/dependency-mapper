"use strict";
/// <reference path="../typings/index.d.ts" />
/** @module util/config */
exports.__esModule = true;
// @ts-check
var meteor_1 = require("./meteor");
var object_1 = require("./object");
/**
 * A configuration class - provides a DB-backed, environment variable / meteor.settings populated set of config values
 *
 * @param {Mongo.Collection} collection the config collection
 * @param {Object} Meteor a reference to the Meteor object
 * @param {Object} [Tracker] an optional reference to Tracker - will be mocked in a non-reactive way if not supplied
 * @param {Object} [connection] an optional override for the DDP connection to use to subscribe to the config pub
 * @class Configuration
 */
var Configuration = (function () {
    function Configuration(_a) {
        var collection = _a.collection, Meteor = _a.Meteor, Tracker = _a.Tracker, connection = _a.connection;
        meteor_1.assert(collection, 'Missing collection in Configuration constructor');
        meteor_1.assert(Meteor, 'Missing reference to Meteor in Configuration constructor');
        // in-memory store of config values
        this.items = {};
        // tracker dep
        this.dependency = Tracker ? new Tracker.Dependency() : this._trackerMock();
        // ref to Meteor
        this.Meteor = Meteor;
        // DB store
        this._collection = collection;
        // DDP connection for pub/sub
        // this.connection = connection || (Meteor as any as DDP.DDPStatic)
        this._handlePubSub(connection);
    }
    /**
     * An internal function to provide a default Tracker object (which does NOT support reactivity)
     *
     * @returns {Object} a mocked Tracker object
     * @memberof Configuration
     */
    Configuration.prototype._trackerMock = function () {
        return {
            depend: function (fromComputation) { return true; },
            changed: function () { },
            hasDependents: function () { return false; }
        };
    };
    /**
     * An internal method to provide public configuration values to clients
     *
     * @param {any} cb A callback to be called when the subscription is ready
     *
     * @memberof Configuration
     */
    Configuration.prototype._handlePubSub = function (connection) {
        var _this = this;
        var callback = function () {
            if (_this._observer) {
                _this._observer.stop();
            }
            _this._cursor = _this._collection.find({});
            _this._observer = _this._getObserver(_this._cursor);
        };
        if (this.Meteor.isServer) {
            this.Meteor.publish('__public_configuration', function () { return _this._collection.find({ public: true }); });
            callback();
        }
        else if (connection) {
            connection.subscribe('__public_configuration', {
                onReady: callback,
                onStop: callback
            });
        }
    };
    /**
     * A method to get a handle to an observer from a cursor
     *
     * @param {Mongo.Cursor} cursor
     * @returns handle to a observer
     *
     * @memberof Configuration
     */
    Configuration.prototype._getObserver = function (cursor) {
        var self = this;
        return cursor.observeChanges({
            added: function documentAddedHandler(id, fields) {
                fields.isPublic = fields.public;
                self.addItem(Object.assign(fields, { added: true }));
            },
            changed: function documentChangedHandler(id, fields) {
                // this only works because the id is the same as the key,
                // meaning we don't have to have all the fields at hand here
                var doc = self._collection.findOne(id);
                doc.isPublic = doc.public;
                self.set(id, Object.assign(doc, { options: { isFromObserver: true } }));
            },
            removed: function () { }
        });
    };
    /**
     * Check whether the type of something matches what is expected
     *
     * @param {any} type Either a constructor, or a string. To be checked against the result of `typeof`
     * @param {any} value The value to check
     * @returns {Boolean} whether the type matches
     *
     * @memberof Configuration
     */
    Configuration.prototype._checkType = function (type, value) {
        if (typeof type === 'function') {
            if (value instanceof type) {
                // instance check ( e.g. for `var str = new String("...` )
                return true;
            }
            // turn `function String (...` into `"string"`
            type = type.name.toLowerCase();
        }
        return typeof value === type;
    };
    /**
     * Gets a value from process.env / meteor.settings or falls back to the one provided
     *
     * @param {any} key The key for the value
     * @param {any} value The default value
     * @returns {any}
     *
     * @memberof Configuration
     */
    Configuration.prototype._getValue = function (key, value) {
        if (this.Meteor.isServer) {
            if (this._collection.findOne(key)) {
                value = this._collection.findOne(key).value;
            }
            if (object_1.didResolve(process, "env." + key)) {
                try {
                    value = JSON.parse(process.env[key]);
                }
                catch (ex) {
                    value = process.env[key];
                }
            }
            if (object_1.didResolve(this.Meteor, "settings." + key)) {
                value = this.Meteor.settings[key];
            }
        }
        else if (object_1.didResolve(this.Meteor, "settings.public." + key)) {
            value = this.Meteor.settings.public[key];
        }
        return value;
    };
    /**
     * Adds a value to the in-memory store & upserts it to the db (unless overwrite is present and `false`)
     *
     * @param {any} { key, value, type, isPublic, overwrite, added }
     *
     * @memberof Configuration
     */
    Configuration.prototype.addItem = function (_a) {
        var key = _a.key, value = _a.value, type = _a.type, isPublic = _a.isPublic, isPrivileged = _a.isPrivileged, overwrite = _a.overwrite, added = _a.added;
        if (type) {
            meteor_1.assert(type && this._checkType(type, value), "Type check failed: " + JSON.stringify({ key: key, type: type, value: value }));
        }
        value = this._getValue(key, value);
        if (this.Meteor.isServer) {
            isPublic = typeof isPublic === 'boolean' ? isPublic : false;
            var typeStr = type;
            if (typeof type === 'function') {
                typeStr = type.name.toLowerCase();
            }
            var doc = {
                key: key,
                value: value,
                type: typeStr,
                public: isPublic,
                privileged: isPrivileged
            };
            if (overwrite !== false) {
                // upsert isn't working with autovalues
                if (this._collection.findOne(key)) {
                    this._collection.update(key, { $set: doc }, { removeEmptyStrings: false });
                }
                else if (!added) {
                    doc._id = key;
                    this._collection.insert(doc, { removeEmptyStrings: false });
                }
            }
        }
        var item = Object.assign({ value: value, type: type }, this._collection.findOne({ key: key }) || {});
        this.items[key] = item;
        this.dependency.changed();
    };
    /**
     * Gets the in-memory value for a given key
     *
     * @param {any} key
     * @returns {any} the value
     *
     * @memberof Configuration
     */
    Configuration.prototype.get = function (key) {
        this.dependency.depend();
        return this.items[key] && this.items[key].value;
    };
    /**
     * Update the in-memory value and stored value in the db
     *
     * @param {any} key
     * @param {any} { value, type, options }
     *
     * @memberof Configuration
     */
    Configuration.prototype.set = function (key, _a) {
        var value = _a.value, type = _a.type, options = _a.options;
        options = options || {};
        var item = this._collection.findOne({ key: key });
        if (!item) {
            return;
        }
        type = type || item.type;
        if (value) {
            var overrides = { value: value };
            if (type) {
                overrides.type = type;
                meteor_1.assert(this._checkType(type, value), "Type check failed: " + JSON.stringify({ key: key, type: type, value: value }));
            }
            if (this.Meteor.isServer && !options.isFromObserver && item.value.toString() !== value.toString()) {
                this._collection.update({
                    _id: key
                }, {
                    $set: { value: value }
                }, { removeEmptyStrings: false });
            }
            this.items[key] = Object.assign(item, overrides);
            this.dependency.changed();
        }
    };
    return Configuration;
}());
exports.Configuration = Configuration;
//# sourceMappingURL=config.js.map