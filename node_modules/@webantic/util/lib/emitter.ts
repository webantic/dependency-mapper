/** @module util/emitter */

export {
  MultiEmitter,
  Emitter
}

/**
 * Basic class that represents an event that can be listened to and broadcasted
 */
class Emitter<T> {

  nextId: number = 0
  listeners: { [key: string]: (value: T) => void } = {}

  /**
   * Add a callback to be ran whenver this event is broadcasted
   */
  listen(callback: (value: T) => void) {
    this.listeners[++this.nextId] = callback;
  }

  /**
   * Calls all callbacks that have been registered with the given value
   * @param value value to broadcast, if any
   */
  broadcast(value: T) {
    _.values(this.listeners).forEach(l => l(value));
  }

  /**
   * Remove all attached listeners
   */
  removeListeners() {
    this.listeners = {};
  }
}

/**
 * Slightly more advanced event emitter style class that allows listening to different events via string arguments
 */
class MultiEmitter {

  nextId: number = 0
  listenersByEvent: { [event: string]: ListenerSet<any> } = {}

  /**
   * Add a callback to be ran whenver this event is broadcasted
   * @param event the event as a string to be listened to
   * @param callback the callback to run whenever said event is triggered
   */
  listen(event: string, callback: (value: any) => void) {
    if (!this.listenersByEvent[event]) {
      this.listenersByEvent[event] = {}
    }

    this.listenersByEvent[event][++this.nextId] = callback;
  }

  /**
   * Broadcast an event of the given type
   * @param event even type to broadcast
   * @param value value to be passed to each callback
   */
  broadcast(event: string, value?: any) {
    if (!this.listenersByEvent[event]) {
      return
    }

    _.values(this.listenersByEvent[event]).forEach(l => l(value));
  }

  /**
   * Remove all attached listeners for a specific event type
   * @param event
   */
  removeListeners(event: string) {
    delete this.listenersByEvent[event]
  }
}

export type ListenerSet<T> = { [key: string]: (value: T) => void }
